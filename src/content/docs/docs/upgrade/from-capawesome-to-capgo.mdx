---
title: Migrate from Capawesome Cloud to Capgo
description: Step-by-step guide to move from Capawesome Cloud to Capgo while gaining native OTA safety, device-level observability, and full automation.
sidebar:
  order: 8
---

> ⚡️ Capgo automates channels, bundle cleanup, rollbacks, analytics, and CLI uploads natively. Use this guide to perform the minimal steps required to migrate and optionally recreate any custom behaviour you still need.

## Overview

1. Gather your existing Capawesome Cloud configuration (App ID, channels, signing keys, CLI tokens) so you can archive or audit it later.
2. Install the Capgo plugin, remove the Capawesome SDK, and call `CapacitorUpdater.notifyAppReady()`.
3. Configure optional behaviour (manual downloads, pinning bundles, reloads) if you rely on those flows today.

With Capgo you only need to install our plugin and call `CapacitorUpdater.notifyAppReady()`. Everything else—channels, bundle cleanup, rollbacks, analytics, and CLI automation—is handled natively. The sections below walk through each task directly.

## Before you start

- Make sure your project is already using Capacitor 5 or later.
- Install the Capgo CLI (`npm install -g @capgo/cli`) if you plan to push bundles from CI/CD.

## Step 1 – Install Capgo and remove the Capawesome SDK

```bash
npm uninstall @capawesome/capacitor-live-update
npm install @capgo/capacitor-updater
npx cap sync
```

That is the only mandatory swap. Capgo’s native code ships with the plugin; no extra JavaScript helpers are required.

## Step 2 – Minimal configuration

The previous setup required mapping dozens of options in `capacitor.config`. Capgo recognises your project automatically, so the minimal configuration looks like this:

```ts title="capacitor.config.ts"
import { CapacitorConfig } from '@capacitor/cli'

const config: CapacitorConfig = {
  plugins: {
    CapacitorUpdater: {
      autoUpdate: true,
      autoDeletePrevious: true,
      periodCheckDelay: 10 * 60 * 1000, // optional: check every 10 minutes
    },
  },
}

export default config
```

Everything Capawesome lists as manual flags (`defaultChannel`, `autoDeleteBundles`, retention policies, etc.) is managed through the Capgo dashboard or API. You only need to override these keys if you want behaviour that differs from Capgo’s defaults.

### Configuration quick reference

| Capawesome option | Capgo equivalent | Do you need to set it? |
| --- | --- | --- |
| `appId` | Taken from the Capgo dashboard once you create a project | Only if you use multiple projects in one binary |
| `defaultChannel` | Channel rules managed in the dashboard/API | Optional; most teams set this server-side |
| `autoDeleteBundles` | `autoDeletePrevious: true` (default) | Already enabled |
| `publicKey` | Managed in Capgo console | Only if you rotate keys manually |
| `maxVersions` / retention | Bundle retention policy | Configured centrally in Capgo (1 month default, 24 months max) |

## Step 3 – Call `notifyAppReady()` (the only required hook)

The old workflow introduced custom listeners (`checkForUpdates()`, `retryDownload()`, hiding the splash screen, etc.). Capgo performs those steps natively. The only API you must call is:

```ts
import { CapacitorUpdater } from '@capgo/capacitor-updater'

CapacitorUpdater.notifyAppReady()
```

This confirms the app booted successfully. If the confirmation never arrives, Capgo automatically rolls back the bundle—no extra JavaScript needed.

**That's it—Capgo handles background checks, splash visibility, and rollbacks natively.**

<details>
<summary>Optional: run custom logic before the splash screen hides</summary>

```ts
import { CapacitorUpdater } from '@capgo/capacitor-updater'
import { SplashScreen } from '@capacitor/splash-screen'

CapacitorUpdater.addListener('appReady', () => {
  // Run diagnostics or logging if you need to
  SplashScreen.hide()
})

CapacitorUpdater.notifyAppReady()
```

</details>

## Step 4 – Map API calls (mostly optional)

In Capgo you normally let the auto-updater run; manual APIs remain available if you want full control.

| Capawesome Cloud | Capgo equivalent | Do you need it? |
| --- | --- | --- |
| `LiveUpdate.fetchLatestBundle()` | `CapacitorUpdater.getLatest()` | Only when implementing your own download workflow |
| `LiveUpdate.downloadBundle()` | `CapacitorUpdater.download()` | Optional: native auto-update already downloads |
| `LiveUpdate.setNextBundle()` | `CapacitorUpdater.next()` | Optional: dashboard pins bundles automatically |
| `LiveUpdate.reload()` | `CapacitorUpdater.reload()` | Optional; Capgo enforces mandatory bundles after `notifyAppReady()` |
| `LiveUpdate.getCurrentBundle()` | `CapacitorUpdater.current()` | Optional diagnostics |

If you stick with the native auto-update behaviour you can delete the Capawesome JavaScript entirely.

### Manual control examples

**Download the latest bundle**

```ts title="Capgo"
import { CapacitorUpdater } from '@capgo/capacitor-updater'

const downloadUpdate = async () => {
  const latest = await CapacitorUpdater.getLatest()
  if (latest?.url) {
    const bundle = await CapacitorUpdater.download({
      url: latest.url,
      version: latest.version,
    })
    console.log('Bundle downloaded', bundle?.id)
  }
}
```

```ts title="Capawesome Cloud"
import { LiveUpdate } from '@capawesome/capacitor-live-update'

const downloadUpdate = async () => {
  const result = await LiveUpdate.fetchLatestBundle()
  if (result.downloadUrl) {
    await LiveUpdate.downloadBundle({
      bundleId: result.bundleId,
      url: result.downloadUrl,
    })
    console.log('Bundle downloaded')
  }
}
```

**Set the next bundle**

```ts title="Capgo"
import { CapacitorUpdater } from '@capgo/capacitor-updater'

const setNextBundle = async () => {
  await CapacitorUpdater.next({ id: 'bundle-id-123' })
}
```

```ts title="Capawesome Cloud"
import { LiveUpdate } from '@capawesome/capacitor-live-update'

const setNextBundle = async () => {
  await LiveUpdate.setNextBundle({ bundleId: 'bundle-id-123' })
}
```

**Apply the downloaded bundle immediately**

```ts title="Capgo"
import { CapacitorUpdater } from '@capgo/capacitor-updater'

const applyUpdate = async () => {
  await CapacitorUpdater.reload()
}
```

```ts title="Capawesome Cloud"
import { LiveUpdate } from '@capawesome/capacitor-live-update'

const applyUpdate = async () => {
  await LiveUpdate.reload()
}
```

## Step 5 – Update strategies: how Capgo handles them

Capawesome documents three strategies. Here’s how they translate:

### Background updates
- **Previous workflow**: configure in code and schedule downloads manually.
- **Capgo**: enabled by default (`autoUpdate: true`). No additional code required.

### Always latest
- **Previous workflow**: add an `App.resume` listener, call `download`, then `set`.
- **Capgo**: background auto-update already performs the check after resume. You only need the manual listener if you want a custom interval.

<details>
<summary>Optional: manual resume check</summary>

```ts
import { App } from '@capacitor/app'
import { CapacitorUpdater } from '@capgo/capacitor-updater'

App.addListener('resume', async () => {
  const latest = await CapacitorUpdater.getLatest()
  if (latest?.url) {
    const downloaded = await CapacitorUpdater.download({
      url: latest.url,
      version: latest.version,
    })
    if (downloaded) {
      await CapacitorUpdater.next({ id: downloaded.id })
    }
  }
})
```

</details>

### Force update
- **Previous workflow**: wire prompt logic and enforce reload.
- **Capgo**: mark the bundle as “mandatory” in the dashboard. The SDK enforces it automatically after `notifyAppReady()`.

## Step 6 – Deploying bundles

If you previously relied on `capawesome live-update deploy`, Capgo offers a similar CLI workflow, and you can also automate deployments entirely via API.

```bash
# Authenticate once (stores a token in your CI environment)
capgo login

# Upload a new bundle (auto-detects platform/version)
capgo bundle upload --path dist --channel production
```

Because Capgo tracks bundle health automatically, you also get:

- Device-level audit logs for every install.
- Automatic retention (one month by default) with configurable limits up to 24 months.
- Real-time latency metrics at [status.capgo.app/history](https://status.capgo.app/history).

## Migration timeline

- **Inventory & install**: 10 minutes (`npm install`, remove old plugin).
- **Config & readiness**: 5 minutes (`notifyAppReady`).
- **Sanity checks**: 15 minutes (optional manual tests or listeners).
- **First deployment**: 10 minutes with Capgo CLI or CI integration.

In practice teams finish in under an hour. If you provide Capawesome project details we can even import channels and device lists for you.

## Capgo support

- **Migration concierge**: book a session at [cal.com/team/capgo/demo](https://cal.com/team/capgo/demo).
- **Community**: join the [Capgo Discord](https://discord.gg/VCXxSVjefW).
- **Issue tracker**: [github.com/Cap-go/capacitor-updater/issues](https://github.com/Cap-go/capacitor-updater/issues).

Capgo is built for long-term reliability: native delta updates, encrypted bundles, automatic rollbacks, and analytics that do not require custom JavaScript. Once you migrate you can delete the maintenance-heavy glue and let the platform run updates automatically.
