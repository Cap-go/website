---
title: CI/CD Integration
description: Integrating Capgo into your CI/CD pipeline allows you to fully automate the process of building and deploying updates to your app. By leveraging the Capgo CLI and semantic-release, you can ensure consistent, reliable deployments and enable rapid iteration.
sidebar:
  order: 4
---

import { Steps, Code } from '@astrojs/starlight/components';

Integrating Capgo into your CI/CD pipeline allows you to fully automate the process of building and deploying updates to your app. By leveraging the Capgo CLI and semantic-release, you can ensure consistent, reliable deployments and enable rapid iteration.

## Benefits of CI/CD Integration

- **Automation**: No more manual steps or room for human error. Your entire build, test, and deployment process can be automated from end to end.

- **Consistency**: Every deployment follows the same set of steps, ensuring a predictable and repeatable process. This is especially valuable when you have multiple team members contributing code.

- **Faster iterations**: With automated deployments, you can ship updates more frequently and with confidence. No more waiting for manual QA or release approvals.

## Capgo CLI

The Capgo CLI is the key to integrating Capgo into your CI/CD workflow. It provides commands for pushing new bundle versions, managing channels, and more.

The most important command for CI/CD integration is `bundle upload`:

```shell
npx @capgo/cli@latest bundle upload --channel Production --apikey YOUR_API_KEY
```

If you use encryption you shoud provide it from one of this way:
```shell
npx @capgo/cli@latest bundle upload --channel Production --apikey YOUR_API_KEY --key-v2 PRIVATE_KEY_PATH
```

Alternatively you can provide the key data that way:
```shell
npx @capgo/cli@latest bundle upload --channel Production --apikey YOUR_API_KEY --key-v2-data PRIVATE_KEY_CONTENT
```
Use pbcopy like that
```shell
cat .capgo_key | pbcopy
```
To copy the key data and paste it in your Secret env of your CI/CD 

This command uploads the current web build to the specified channel. You'll typically run this as the last step in your CI/CD pipeline, after your web build has completed successfully.

## Setting up Capgo in your CI/CD Pipeline

While the exact steps will vary depending on your CI/CD tool of choice, the general process for integrating Capgo looks like this:

<Steps>
1. **Generate an API key**: Log in to the Capgo dashboard and create a new API key. This key will be used to authenticate the CLI in your CI/CD environment. Keep it secret and never commit it to your repository!

3. **Configure the `bundle upload` command**: Add a step to your CI/CD configuration that runs the `bundle upload` command with the appropriate arguments: <Code lang="yaml" title="upload.yml" code={`- run: npx @capgo/cli@latest bundle upload --channel=Production --apikey=$\{\{ secrets.CAPGO_API_KEY \}\}`} />\n Replace `Production` with the channel you want to deploy to, and `${{ secrets.CAPGO_API_KEY }}` with the environment variable holding your API key.

4. **Add the `upload` step after your web build**: Ensure that the `upload` step comes after your web build has completed successfully. This ensures you're always deploying your latest code.\n  Here's an example configuration for GitHub Actions:\n<Code lang="yaml" title="upload.yml" code={`name: Deploy to Capgo\n on:\n  push:\n   branches: [main]\n\njobs:\n deploy:\n runs-on: ubuntu-latest\n\n steps:\n - uses: actions/checkout@v3\n - uses: actions/setup-node@v3\n  with:\n   node-version: 18\n\n - run: npm ci\n - run: npm run build\n\n - run: npm install -g @capgo/cli\n - run: npx @capgo/cli@latest bundle upload --channel=Production --apikey=$\{\{ secrets.CAPGO_API_KEY \}\}`} />

</Steps>

## Semantic-release Integration

Semantic-release is a powerful tool for automating version management and generating release notes. By integrating semantic-release with Capgo, you can automatically increment your app version and generate changelogs with each deployment.

Here's a sample `.releaserc` configuration file for semantic-release:

```json
{
  "branches": [
    "main",
    {
      "name": "beta",
      "prerelease": true
    }
  ],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    [
      "@semantic-release/exec",
      {
        "publishCmd": "npx @capgo/cli@latest bundle upload --channel=${nextRelease.channel} --apikey YOUR_API_KEY --partial"
      }
    ],
    [
      "@semantic-release/git",
      {
        "assets": ["CHANGELOG.md", "package.json"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ]
  ]
}
```

This configuration does the following:

1. Analyzes commit messages to determine the next version number, following the Conventional Commits spec.
2. Generates release notes based on the commits since the last release.
3. Updates the `CHANGELOG.md` file with the new release notes.
4. Runs the Capgo CLI `bundle upload` command, passing the new version number and using the `--partial` flag for differential updates.
5. Commits the updated `CHANGELOG.md`, `package.json`, and any other changed files back to the repository.

To use semantic-release with Capgo, simply add a step to your CI/CD configuration that runs `npx semantic-release`. Ensure this step comes after your web build and before the Capgo `bundle upload` step.

## Troubleshooting

If you encounter issues with your Capgo CI/CD integration, here are a few things to check:

- **API key**: Ensure your API key is valid and has the necessary permissions. If using an environment variable, double check that it's set correctly.

- **CLI version**: Make sure you're using the latest version of the Capgo CLI. Older versions may have compatibility issues or lack certain features.

- **Build artifacts**: Confirm that your web build is generating the expected output files. The Capgo CLI needs a valid web build to create a bundle.

- **Network connectivity**: Check that your CI/CD environment has network access to the Capgo servers. Firewall or proxy issues can sometimes interfere with the `upload` command.

If you're still having trouble, reach out to Capgo support for assistance. They can help troubleshoot any issues with your specific setup.

## Handling Private Keys in CI/CD Environments

When using encryption v2 in a CI/CD environment, you'll need to provide both your API key and private key to the CLI. Here's how to handle this securely:

### Storing Private Keys as Environment Variables

1. **Never commit your private key to version control**
2. **Store the private key as a secret/environment variable:**
   - GitHub Actions: Use repository secrets
   - GitLab CI: Use CI/CD variables
   - Google Cloud Build: Use substitution variables
   - Jenkins: Use credentials

### Proper Key Formatting

When storing your private key as an environment variable, you must ensure it's properly formatted to avoid errors like `error:1E080110:DECODER routines::unsupported`.

Here are some common issues and solutions:

1. **Preserve line breaks**: Private keys in PEM format contain line breaks that must be preserved. Different CI/CD systems handle this differently:

   - **GitHub Actions**: Use the built-in support for multiline secrets:
     ```yaml
     - name: Upload bundle
       run: npx @capgo/cli@latest bundle upload --channel="prod" --apikey="${{ secrets.CAPGO_API_KEY }}" --key-data-v2="${{ secrets.CAPGO_PRIVATE_KEY }}" --auto-set-bundle
       env:
         CAPGO_PRIVATE_KEY: ${{ secrets.CAPGO_PRIVATE_KEY }}
     ```

   - **GitLab CI**: Use the `|-` YAML syntax to preserve newlines:
     ```yaml
     variables:
       CAPGO_PRIVATE_KEY: |-
         -----BEGIN PRIVATE KEY-----
         MIIEvgIBADANBgkqhkiG9w0BAQEFAA...
         -----END PRIVATE KEY-----
     ```

   - **Google Cloud Build**: For substitution variables, you may need to replace newlines with `\n` and then use a script to restore them:
     ```yaml
     steps:
     - name: 'gcr.io/cloud-builders/npm'
       script: |
         echo "$_CAPGO_PRIVATE_KEY" | sed 's/\\n/\n/g' > private_key.pem
         npx @capgo/cli@latest bundle upload --channel="prod" --apikey="${_CAPGO_API_KEY}" --key-v2="private_key.pem" --auto-set-bundle
       env:
         - '_CAPGO_API_KEY=${_CAPGO_API_KEY}'
         - '_CAPGO_PRIVATE_KEY=${_CAPGO_PRIVATE_KEY}'
     ```

2. **Correct PEM format**: Ensure your private key is in the correct PEM format with proper headers and footers:
   ```
   -----BEGIN PRIVATE KEY-----
   (base64-encoded key data)
   -----END PRIVATE KEY-----
   ```

3. **No extra whitespace**: Make sure there's no extra whitespace before or after the key content.

### Example CI/CD Configurations

#### GitHub Actions

```yaml
name: Deploy to Capgo
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18

      - run: npm ci
      - run: npm run build

      - name: Upload to Capgo
        run: npx @capgo/cli@latest bundle upload --channel=Production --apikey=${{ secrets.CAPGO_API_KEY }} --key-data-v2="${{ secrets.CAPGO_PRIVATE_KEY }}"
```

#### GitLab CI

```yaml
deploy:
  stage: deploy
  image: node:18
  script:
    - npm ci
    - npm run build
    - |
      npx @capgo/cli@latest bundle upload \
        --channel=Production \
        --apikey=${CAPGO_API_KEY} \
        --key-data-v2="${CAPGO_PRIVATE_KEY}"
  only:
    - main
```

#### Google Cloud Build

```yaml
steps:
- name: node:18
  entrypoint: npm
  args: ['ci']
- name: node:18
  entrypoint: npm
  args: ['run', 'build']
- name: node:18
  entrypoint: bash
  args:
    - '-c'
    - |
      echo "$_CAPGO_PRIVATE_KEY" | sed 's/\\n/\n/g' > private_key.pem
      npx @capgo/cli@latest bundle upload --channel="prod" --apikey="${_CAPGO_API_KEY}" --key-v2="private_key.pem" --auto-set-bundle
```

### Troubleshooting Key Format Issues

If you encounter the error `error:1E080110:DECODER routines::unsupported`, it typically means there's an issue with how your private key is formatted. Try these solutions:

1. **Check for line break issues**: Ensure line breaks in your private key are properly preserved.
2. **Verify the key format**: Make sure you're using a supported key format (PEM).
3. **Use a file instead of inline data**: If you continue to have issues with `--key-data-v2`, try writing the key to a temporary file and using `--key-v2` instead:
   ```bash
   echo "$PRIVATE_KEY" > temp_key.pem
   npx @capgo/cli@latest bundle upload --channel=Production --apikey=$CAPGO_API_KEY --key-v2=temp_key.pem
   ```
4. **Inspect the key format**: You can check if your key is in the correct format by examining the first few characters (without exposing the entire key):
   ```bash
   echo "$PRIVATE_KEY" | head -1
   # Should output: -----BEGIN PRIVATE KEY-----
   ```

## Conclusion

Integrating Capgo into your CI/CD pipeline and leveraging semantic-release for version management can greatly streamline your development workflow. By automating your deployments and versioning, you can ship updates faster and with more confidence.

The Capgo CLI and semantic-release provide a powerful combination for achieving fully automated, end-to-end releases. With a bit of configuration, you can have a robust and reliable deployment process that allows you to focus on building great features rather than worrying about manual release steps.

For more details on the Capgo CLI commands and options, check out the [CLI reference](/docs/cli/overview). And for a deeper dive into semantic-release configuration, see the [semantic-release docs](https://github.com/semantic-release/semantic-release).

Happy deploying!
