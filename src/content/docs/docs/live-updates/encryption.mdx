---
title: Encryption
description: "Learn how Capgo's end-to-end encryption secures your app bundles during transmission and storage, protecting your code and user data."
sidebar:
  order: 5
---

import { Aside, Steps } from '@astrojs/starlight/components';

Capgo provides robust end-to-end encryption for your app bundles, ensuring that your JavaScript code and assets are protected during transmission and storage. This encryption system is designed to give you complete control over your app's security while maintaining the convenience of live updates.

## Overview

Capgo's encryption system uses industry-standard cryptographic methods to protect your bundles from unauthorized access. When encryption is enabled, your bundles are encrypted before leaving your development environment and remain encrypted until they're decrypted by your app on the user's device.

**True End-to-End Encryption**: Unlike other OTA update platforms that only sign updates (leaving the code publicly readable), Capgo is the only solution that provides true end-to-end encryption. This means your bundle content remains completely private and unreadable by anyone - including Capgo itself - throughout the entire delivery process.

<Aside type="tip">

Encryption is particularly important for:
- Apps handling sensitive data or business logic
- Enterprise applications with compliance requirements
- Apps deployed in regulated industries
- Organizations with strict security policies

</Aside>

## How Encryption Works

Capgo uses a hybrid encryption approach that combines RSA and AES encryption for optimal security and performance:

![Capgo Encryption Flow](/encryption_flow.webp)

### 1. Key Generation
- **Private Key**: Generated and stored securely in your development environment (used for decryption)
- **Public Key**: Derived from your private key and uploaded to Capgo (used for encryption)
- **Session Keys**: Random AES keys generated for each bundle upload

### 2. Encryption Process
1. A random AES session key is generated for each bundle upload
2. Your bundle is encrypted using the AES session key
3. The bundle checksum is calculated
4. Both the AES session key and checksum are encrypted together using your RSA private key (creating the "signature")
5. The encrypted bundle and encrypted signature are stored

The checksum is encrypted alongside the AES key to prevent tampering. Since only your RSA private key can create this signature, and only the corresponding public key can decrypt it, this ensures that both the AES session key and the expected checksum are authentic and haven't been modified by an attacker.

### 3. Decryption Process
1. Your app downloads the encrypted bundle and encrypted signature
2. The Capgo SDK uses your RSA public key (stored in the app) to decrypt the signature
3. This reveals the AES session key and the original checksum
4. The AES session key is used to decrypt the bundle
5. A checksum of the decrypted bundle is calculated and compared with the original checksum for integrity verification

This process ensures that even if an attacker intercepts the encrypted bundle, they cannot modify the AES session key or provide a fake checksum, because they would need your private key to create a valid signature that the public key can decrypt.

<Aside type="tip">

RSA cannot encrypt large amounts of data efficiently, so AES is used for the actual bundle encryption while RSA secures the AES key and provides integrity verification through checksum signing.

</Aside>

## Capgo vs Other Platforms

| Feature | Capgo | Other OTA Platforms |
|---------|-------|-------------------|
| **Bundle Content** | Fully encrypted (unreadable) | Publicly readable |
| **Security Method** | True end-to-end encryption | Code signing only |
| **Privacy Level** | Zero-knowledge (even Capgo can't read your code) | Platform can access your code |
| **Protection** | Content + integrity + authenticity | Integrity + authenticity only |

**Why This Matters:**
- **Code signing** only verifies that updates haven't been tampered with and come from the right source
- **End-to-end encryption** additionally ensures that your actual code content remains private and unreadable during transmission and storage
- With Capgo, even if someone gains access to the storage servers, your code remains completely protected

## Encryption Methods

Capgo uses Encryption V2 as the standard encryption method:

### Encryption V2 (Current Standard)
- Uses RSA-4096 for enhanced security
- AES-256-GCM for authenticated encryption
- Provides integrity verification
- Better performance and security

### Encryption V1 (Deprecated)
- Uses RSA-2048 for key encryption
- AES-256-CBC for bundle encryption
- **No longer available in the current CLI**
- Legacy apps using V1 must migrate to V2

<Aside type="danger">

Encryption V1 is no longer supported in the current Capgo CLI. If you're using V1 encryption, you must migrate to V2. See the [migration guide](/docs/upgrade/encryption-v1-to-v2/) for detailed instructions.

</Aside>

## Setting Up Encryption

### Step 1: Generate Encryption Keys

First, generate your encryption keys using the Capgo CLI:

```shell
# Generate new encryption keys
npx @capgo/cli@latest key create

# Or specify a custom path
npx @capgo/cli@latest key create --path ./my-keys/
```

This creates:
- `private_key.pem`: Your private key (keep this secure!)
- `public_key.pem`: Your public key (uploaded to Capgo)

### Step 2: Configure Your App

Add the public key to your app's configuration. In your `capacitor.config.ts`:

```ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  plugins: {
    CapacitorUpdater: {
      publicKey: `-----BEGIN RSA PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END RSA PUBLIC KEY-----`,
    },
  },
};

export default config;
```

<Aside type="caution">

The public key can be safely committed to version control as it's used for decryption on the device. Keep your private key secure and never commit it to version control - it's used for encryption during the upload process.

</Aside>

### Step 3: Save Your Private Key for CLI

Save your private key for use with the Capgo CLI (for encryption during uploads):

```shell
npx @capgo/cli@latest key save --key ./private_key.pem
```

This stores the private key securely for the CLI to use when encrypting bundles during upload.

## Encrypting Bundles

### Method 1: Encrypt During Upload

The simplest way is to encrypt during the upload process:

```shell
# Upload with automatic encryption
npx @capgo/cli@latest bundle upload --key-v2

# Upload to custom storage with encryption
npx @capgo/cli@latest bundle upload --external https://your-cdn.com/bundle.zip --key-v2
```

### Method 2: Manual Encryption Workflow

For more control, you can manually encrypt bundles:

<Steps>

1. **Create a zip bundle:**
   ```shell
   npx @capgo/cli@latest bundle zip com.example.app --path ./dist --key-v2
   ```

2. **Encrypt the bundle:**
   ```shell
   npx @capgo/cli@latest bundle encrypt ./com.example.app.zip CHECKSUM_FROM_STEP_1
   ```

3. **Upload the encrypted bundle:**
   ```shell
   npx @capgo/cli@latest bundle upload --external https://your-storage.com/encrypted-bundle.zip --iv-session-key IV_SESSION_KEY_FROM_STEP_2
   ```

</Steps>

## Key Management

### Storing Keys Securely

**Private Key (for CLI/CI):**
```shell
# Store in environment variable for CI
export CAPGO_PRIVATE_KEY="$(cat private_key.pem)"
```

**Production Environment:**
- Store private keys in secure key management services (AWS KMS, Azure Key Vault, etc.)
- Use CI/CD secret management for private keys
- Public keys can be safely stored in your app configuration

**Key Usage:**
- **Private Key**: Used by CLI for encryption during bundle upload (keep secure)
- **Public Key**: Stored in app configuration for decryption on device (safe to commit)

### Key Rotation

Regularly rotate your encryption keys for enhanced security:

<Steps>

1. **Generate new keys:**
   ```shell
   npx @capgo/cli@latest key create --path ./new-keys/
   ```

2. **Save the new private key for CLI:**
   ```shell
   npx @capgo/cli@latest key save --key ./new-keys/private_key.pem
   ```

3. **Update your app configuration** with the new public key

4. **Deploy the updated app** before uploading encrypted bundles with the new key

</Steps>

## Security Best Practices

### Key Security
- **Never share private keys** between environments or team members
- **Use different keys** for different environments (dev, staging, production)
- **Rotate keys regularly** (recommended: every 6-12 months)
- **Store keys securely** using proper key management systems

### Bundle Security
- **Always verify** bundle integrity after decryption
- **Monitor** for unusual download patterns or failures
- **Use HTTPS** for all bundle URLs (required for mobile apps)
- **Implement** proper error handling for decryption failures

### Access Control
- **Limit access** to encryption keys to authorized personnel only
- **Use role-based access** for key management operations
- **Audit** key usage and access regularly
- **Implement** proper backup and recovery procedures

## Troubleshooting Encryption

### Common Issues

**Decryption failures:**
- Verify the private key matches the public key used for encryption
- Check that the `ivSessionKey` is correct
- Ensure you're using Encryption V2 (V1 is no longer supported)

**Key-related errors:**
- Confirm the private key format is correct (PEM format)
- Verify the key hasn't been corrupted during storage/transfer
- Check that the key has proper permissions in your app configuration

**Performance issues:**
- Large bundles may take longer to encrypt/decrypt
- Consider using differential updates to reduce bundle sizes
- Monitor device performance during decryption

### Debug Commands

Check encryption status:
```shell
npx @capgo/cli@latest app debug
```

Verify key configuration:
```shell
npx @capgo/cli@latest key check
```

Test encryption/decryption:
```shell
npx @capgo/cli@latest bundle encrypt ./test.zip CHECKSUM --json
```

## Compliance and Standards

Capgo's encryption implementation follows industry standards:

- **AES-256**: FIPS 140-2 approved encryption algorithm
- **RSA-4096**: Strong asymmetric encryption for key protection
- **GCM Mode**: Provides both confidentiality and authenticity
- **Secure Random**: Cryptographically secure random number generation

This makes Capgo suitable for applications requiring compliance with:
- GDPR (General Data Protection Regulation)
- HIPAA (Health Insurance Portability and Accountability Act)
- SOC 2 (Service Organization Control 2)
- ISO 27001 (Information Security Management)

## Performance Considerations

### Encryption Overhead
- **Bundle size**: Encrypted bundles are slightly larger (~1-2% overhead)
- **Processing time**: Encryption/decryption adds minimal latency
- **Memory usage**: Temporary increase during encryption/decryption operations

### Optimization Tips
- Use differential updates to minimize encrypted data transfer
- Consider bundle splitting for very large applications
- Monitor device performance on older/slower devices
- Cache decrypted bundles when possible

## Next Steps

- Learn about [Custom Storage](/docs/live-updates/custom-storage/) to use encryption with your own infrastructure
- Explore [Channels](/docs/live-updates/channels/) to manage encrypted bundles across environments
- Set up [CI/CD Integration](/docs/getting-started/cicd-integration/) to automate encrypted deployments
