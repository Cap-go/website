---
title: "频道 API 端点"
description: "如何为自托管 Capgo 构建频道管理端点以处理设备频道分配和频道查询"
sidebar:
  order: 8
locale: zh
---

频道是 Capgo 中管理应用更新的核心机制。在自托管模式下,您需要实现频道端点来处理设备分配、频道查询和频道管理操作。

## 理解频道

频道允许您:
- **控制更新分发**: 将不同的应用版本分配给不同的用户组
- **A/B 测试**: 使用特定用户群测试新功能
- **分阶段发布**: 逐步部署更新以最大程度地降低风险
- **环境分离**: 分离开发、暂存和生产更新

## 配置

在您的 `capacitor.config.json` 中配置频道端点 URL:

```json
{
  "plugins": {
    "CapacitorUpdater": {
      "channelUrl": "https://myserver.com/api/channel_self"
    }
  }
}
```

## 频道操作

插件执行您的端点需要处理的不同频道操作:

### 1. 获取频道 (GET 请求)

当插件调用 `getChannel()` 时,它会发送 GET 请求以检索设备的当前频道分配。

#### Request Format
```typescript
// GET /api/channel_self
// Headers:
{
  "Content-Type": "application/json"
}

// Query parameters or body:
interface GetChannelRequest {
  device_id: string
  app_id: string
  platform: "ios" | "android"
  plugin_version: string
  version_build: string
  version_code: string
  version_name: string
}
```

#### Response Format
```json
{
  "status": "ok",
  "channel": "production",
  "allowSet": true,
  "message": "",
  "error": ""
}
```

### 2. 设置频道 (POST 请求)

当插件调用 `setChannel()` 时,它会发送 POST 请求将设备分配到特定频道。

#### Request Format
```typescript
// POST /api/channel_self
interface SetChannelRequest {
  device_id: string
  app_id: string
  channel: string
  platform: "ios" | "android"
  plugin_version: string
  version_build: string
  version_code: string
  version_name: string
}
```

#### Response Format
```json
{
  "status": "ok",
  "message": "Device assigned to channel successfully",
  "error": ""
}
```

### 3. Unset Channel (DELETE Request)

When the plugin calls `unsetChannel()`, it sends a DELETE request to remove the device's channel assignment.

#### Request Format
```typescript
// DELETE /api/channel_self
interface UnsetChannelRequest {
  device_id: string
  app_id: string
  platform: "ios" | "android"
  plugin_version: string
  version_build: string
  version_code: string
  version_name: string
}
```

## Implementation Example

Here's a JavaScript example of how to implement the channel endpoint:

```typescript
interface ChannelRequest {
  device_id: string
  app_id: string
  channel?: string
  platform: "ios" | "android"
  plugin_version: string
  version_build: string
  version_code: string
  version_name: string
}

interface ChannelResponse {
  status: "ok" | "error"
  channel?: string
  allowSet?: boolean
  message?: string
  error?: string
}

export const handler = async (event) => {
  const method = event.httpMethod || event.method
  const body = JSON.parse(event.body || '{}') as ChannelRequest
  
  const { device_id, app_id, channel, platform } = body

  try {
    switch (method) {
      case 'GET':
        return await getDeviceChannel(device_id, app_id)
        
      case 'POST':
        return await setDeviceChannel(device_id, app_id, channel!, platform)
        
      case 'DELETE':
        return await unsetDeviceChannel(device_id, app_id)
        
      default:
        return {
          status: "error",
          error: "Method not allowed"
        }
    }
  } catch (error) {
    return {
      status: "error",
      error: error.message
    }
  }
}

async function getDeviceChannel(deviceId: string, appId: string): Promise<ChannelResponse> {
  // Query your database for device channel assignment
  const assignment = await database.getDeviceChannel(deviceId, appId)
  
  if (assignment) {
    return {
      status: "ok",
      channel: assignment.channel,
      allowSet: assignment.allowSelfAssign
    }
  }
  
  // Return default channel if no assignment found
  return {
    status: "ok",
    channel: "production", // Your default channel
    allowSet: true
  }
}

async function setDeviceChannel(
  deviceId: string, 
  appId: string, 
  channel: string, 
  platform: string
): Promise<ChannelResponse> {
  // Validate channel exists and allows self-assignment
  const channelConfig = await database.getChannelConfig(channel, appId)
  
  if (!channelConfig) {
    return {
      status: "error",
      error: "Channel not found"
    }
  }
  
  if (!channelConfig.allowDeviceSelfSet) {
    return {
      status: "error",
      error: "Channel does not allow self-assignment"
    }
  }
  
  // Check platform restrictions
  if (platform === "ios" && !channelConfig.ios) {
    return {
      status: "error", 
      error: "Channel not available for iOS"
    }
  }
  
  if (platform === "android" && !channelConfig.android) {
    return {
      status: "error",
      error: "Channel not available for Android" 
    }
  }
  
  // Save the assignment
  await database.setDeviceChannel(deviceId, appId, channel)
  
  return {
    status: "ok",
    message: "Device assigned to channel successfully"
  }
}

async function unsetDeviceChannel(deviceId: string, appId: string): Promise<ChannelResponse> {
  // Remove device channel assignment
  await database.removeDeviceChannel(deviceId, appId)
  
  return {
    status: "ok",
    message: "Device channel assignment removed"
  }
}
```

## Channel Configuration

Your channel system should support these configuration options:

```typescript
interface ChannelConfig {
  name: string
  appId: string
  
  // Platform targeting
  ios: boolean
  android: boolean
  
  // Device restrictions
  allowDeviceSelfSet: boolean  // Allow setChannel() calls
  allowEmulator: boolean
  allowDev: boolean           // Allow development builds
  
  // Update policies
  disableAutoUpdate: "major" | "minor" | "version_number" | "none"
  disableAutoUpdateUnderNative: boolean
  
  // Assignment
  isDefault: boolean          // Default channel for new devices
}
```

## Database Schema Example

You'll need to store channel configurations and device assignments:

```sql
-- Channels table
CREATE TABLE channels (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  app_id VARCHAR(255) NOT NULL,
  ios BOOLEAN DEFAULT true,
  android BOOLEAN DEFAULT true,
  allow_device_self_set BOOLEAN DEFAULT false,
  allow_emulator BOOLEAN DEFAULT true,
  allow_dev BOOLEAN DEFAULT true,
  disable_auto_update VARCHAR(50) DEFAULT 'none',
  disable_auto_update_under_native BOOLEAN DEFAULT false,
  is_default BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(name, app_id)
);

-- Device channel assignments table  
CREATE TABLE device_channels (
  id SERIAL PRIMARY KEY,
  device_id VARCHAR(255) NOT NULL,
  app_id VARCHAR(255) NOT NULL, 
  channel_name VARCHAR(255) NOT NULL,
  assigned_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(device_id, app_id)
);
```

## Error Handling

Handle common error scenarios:

```typescript
// Channel not found
{
  "status": "error",
  "error": "Channel 'beta' not found"
}

// Self-assignment not allowed
{
  "status": "error", 
  "error": "Channel does not allow device self-assignment"
}

// Platform not supported
{
  "status": "error",
  "error": "Channel not available for this platform"
}

// Invalid request
{
  "status": "error",
  "error": "Missing required field: device_id"
}
```

## Best Practices

1. **Security**: Validate all channel assignments against your business rules
2. **Logging**: Log all channel operations for auditing and debugging
3. **Performance**: Cache channel configurations to reduce database queries
4. **Validation**: Verify device_id and app_id authenticity
5. **Rate Limiting**: Implement rate limiting to prevent abuse

## Integration with Updates

Channel assignments work together with your [Update API Endpoint](/docs/plugin/self-hosted/handling-updates/). When a device requests an update, check its channel assignment to determine which version to serve:

```typescript
async function getUpdateForDevice(deviceId: string, appId: string) {
  // Get device's channel assignment
  const channelAssignment = await getDeviceChannel(deviceId, appId)
  const channel = channelAssignment.channel || 'production'
  
  // Get the version assigned to this channel
  const channelVersion = await getChannelVersion(channel, appId)
  
  return {
    version: channelVersion.version,
    url: channelVersion.url,
    checksum: channelVersion.checksum
  }
}
```

This creates a complete self-hosted channel management system that gives you full control over how updates are distributed to your users.
