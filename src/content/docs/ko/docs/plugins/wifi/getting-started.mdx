---
title: 시작하기
description: Capacitor 앱에서 네트워크 연결을 관리하기 위해 WiFi 플러그인을 설치하고 사용하는 방법을 알아보세요.
sidebar:
  order: 2
locale: ko
---

import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Code, Steps } from '@astrojs/starlight/components';
import { PackageManagers } from 'starlight-package-managers'

<Steps>
1. **패키지 설치**
   <PackageManagers pkg="@capgo/capacitor-wifi" pkgManagers={['npm', 'pnpm', 'yarn', 'bun']} />

2. **네이티브 프로젝트와 동기화**
   <PackageManagers type="exec" pkg="cap" args="sync" pkgManagers={['npm', 'pnpm', 'yarn', 'bun']} />

3. **권한 구성**

   **Android**: `AndroidManifest.xml`에 추가:
   ```xml
   <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
   <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
   <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
   <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
   ```

   **iOS**: `Info.plist`에 추가:
   ```xml
   <key>NSLocationWhenInUseUsageDescription</key>
   <string>We need location access to scan WiFi networks</string>
   ```
</Steps>

## 사용법

플러그인을 가져와서 WiFi 연결을 관리하세요:

```typescript
import { CapacitorWifi } from '@capgo/capacitor-wifi';

// Get current WiFi connection info
const getWifiInfo = async () => {
  const info = await CapacitorWifi.getWifiInfo();
  console.log('Connected to:', info.ssid);
  console.log('IP Address:', info.ip);
};

// Scan for available networks
const scanNetworks = async () => {
  const { networks } = await CapacitorWifi.scan();
  networks.forEach(network => {
    console.log(`SSID: ${network.ssid}, Signal: ${network.level}`);
  });
};

// Connect to a network
const connectToWifi = async () => {
  await CapacitorWifi.connect({
    ssid: 'MyNetwork',
    password: 'mypassword'
  });
};
```

## API 참조

### getWifiInfo()

현재 연결된 WiFi 네트워크에 대한 정보를 가져옵니다.

```typescript
interface WifiInfo {
  ssid: string;          // Network name
  bssid: string;         // MAC address of access point
  ip: string;            // Device IP address
  frequency: number;     // Network frequency (MHz)
  linkSpeed: number;     // Connection speed (Mbps)
  signalStrength: number; // Signal strength (0-100)
}

const info = await CapacitorWifi.getWifiInfo();
```

### scan()

사용 가능한 WiFi 네트워크를 스캔합니다.

```typescript
interface WifiNetwork {
  ssid: string;          // Network name
  bssid: string;         // MAC address
  level: number;         // Signal level (dBm)
  frequency: number;     // Network frequency
  capabilities: string;  // Security capabilities
}

const { networks } = await CapacitorWifi.scan();
```

### connect(options)

WiFi 네트워크에 연결합니다.

```typescript
interface ConnectOptions {
  ssid: string;          // Network name
  password?: string;     // Network password (if secured)
  isHiddenSsid?: boolean; // Whether SSID is hidden
}

await CapacitorWifi.connect({
  ssid: 'MyNetwork',
  password: 'mypassword'
});
```

### disconnect()

현재 WiFi 네트워크에서 연결을 해제합니다.

```typescript
await CapacitorWifi.disconnect();
```

### getSSID()

현재 연결된 네트워크의 SSID를 가져옵니다.

```typescript
const { ssid } = await CapacitorWifi.getSSID();
console.log('Connected to:', ssid);
```

### getIP()

현재 기기의 IP 주소를 가져옵니다.

```typescript
const { ip } = await CapacitorWifi.getIP();
console.log('IP Address:', ip);
```

## 완전한 예제

```typescript
import { CapacitorWifi } from '@capgo/capacitor-wifi';

export class WifiService {
  async getCurrentNetwork() {
    try {
      const info = await CapacitorWifi.getWifiInfo();
      return {
        name: info.ssid,
        strength: this.getSignalQuality(info.signalStrength),
        speed: `${info.linkSpeed} Mbps`,
        ip: info.ip
      };
    } catch (error) {
      console.error('Failed to get WiFi info:', error);
      return null;
    }
  }

  async scanAndConnect(targetSsid: string, password: string) {
    try {
      // Scan for networks
      const { networks } = await CapacitorWifi.scan();

      // Find target network
      const targetNetwork = networks.find(n => n.ssid === targetSsid);

      if (!targetNetwork) {
        throw new Error(`Network ${targetSsid} not found`);
      }

      console.log(`Found network with signal: ${targetNetwork.level} dBm`);

      // Connect to network
      await CapacitorWifi.connect({
        ssid: targetSsid,
        password: password
      });

      console.log('Connected successfully!');
      return true;
    } catch (error) {
      console.error('Connection failed:', error);
      return false;
    }
  }

  async findBestNetwork(preferredNetworks: string[]) {
    const { networks } = await CapacitorWifi.scan();

    // Filter to preferred networks
    const available = networks.filter(n =>
      preferredNetworks.includes(n.ssid)
    );

    if (available.length === 0) {
      return null;
    }

    // Sort by signal strength
    available.sort((a, b) => b.level - a.level);

    return available[0];
  }

  async monitorConnection(callback: (info: WifiInfo | null) => void) {
    const checkConnection = async () => {
      try {
        const info = await CapacitorWifi.getWifiInfo();
        callback(info);
      } catch (error) {
        callback(null);
      }
    };

    // Check every 5 seconds
    const interval = setInterval(checkConnection, 5000);

    // Initial check
    await checkConnection();

    // Return cleanup function
    return () => clearInterval(interval);
  }

  private getSignalQuality(strength: number): string {
    if (strength >= 80) return 'Excellent';
    if (strength >= 60) return 'Good';
    if (strength >= 40) return 'Fair';
    return 'Poor';
  }

  async getNetworkSecurity(ssid: string): Promise<string> {
    const { networks } = await CapacitorWifi.scan();
    const network = networks.find(n => n.ssid === ssid);

    if (!network) {
      return 'Unknown';
    }

    const caps = network.capabilities.toLowerCase();

    if (caps.includes('wpa3')) return 'WPA3';
    if (caps.includes('wpa2')) return 'WPA2';
    if (caps.includes('wpa')) return 'WPA';
    if (caps.includes('wep')) return 'WEP';

    return 'Open';
  }
}
```

## 고급 사용법

### 네트워크 품질 평가

```typescript
const assessNetworkQuality = async () => {
  const info = await CapacitorWifi.getWifiInfo();

  const quality = {
    signal: info.signalStrength >= 70 ? 'Excellent' :
            info.signalStrength >= 50 ? 'Good' :
            info.signalStrength >= 30 ? 'Fair' : 'Poor',
    speed: info.linkSpeed >= 100 ? 'Fast' :
           info.linkSpeed >= 50 ? 'Medium' : 'Slow',
    frequency: info.frequency >= 5000 ? '5GHz' : '2.4GHz'
  };

  console.log('Network Quality:', quality);
  return quality;
};
```

### 선호하는 네트워크에 자동 연결

```typescript
const autoConnect = async (preferredNetworks: Array<{ ssid: string, password: string }>) => {
  const { networks } = await CapacitorWifi.scan();

  for (const preferred of preferredNetworks) {
    const found = networks.find(n => n.ssid === preferred.ssid);

    if (found) {
      try {
        await CapacitorWifi.connect({
          ssid: preferred.ssid,
          password: preferred.password
        });
        console.log(`Connected to ${preferred.ssid}`);
        return true;
      } catch (error) {
        console.error(`Failed to connect to ${preferred.ssid}`);
      }
    }
  }

  return false;
};
```

### 네트워크 변경 감지

```typescript
class NetworkMonitor {
  private currentSsid: string | null = null;
  private listeners: Array<(ssid: string | null) => void> = [];

  async start() {
    setInterval(async () => {
      try {
        const { ssid } = await CapacitorWifi.getSSID();

        if (ssid !== this.currentSsid) {
          this.currentSsid = ssid;
          this.notifyListeners(ssid);
        }
      } catch (error) {
        if (this.currentSsid !== null) {
          this.currentSsid = null;
          this.notifyListeners(null);
        }
      }
    }, 3000);
  }

  onNetworkChange(callback: (ssid: string | null) => void) {
    this.listeners.push(callback);
  }

  private notifyListeners(ssid: string | null) {
    this.listeners.forEach(listener => listener(ssid));
  }
}
```

## 모범 사례

1. **권한**: 네트워크 스캔 전에 위치 권한 요청
2. **오류 처리**: WiFi 작업은 항상 try-catch 블록으로 감싸기
3. **사용자 피드백**: 네트워크 작업 중 로딩 인디케이터 표시
4. **보안**: WiFi 비밀번호를 일반 텍스트로 저장하지 않기
5. **테스팅**: 에뮬레이터에서는 WiFi API가 작동하지 않을 수 있으므로 실제 기기에서 테스트

## 플랫폼 차이점

### iOS
- 네트워크 스캔에 위치 권한 필요
- 프로그래밍 방식으로 네트워크에 연결할 수 없음 (설정 앱 열기)
- 네트워크 세부 정보에 대한 제한된 액세스

### Android
- 완전한 프로그래밍 방식의 WiFi 제어
- 네트워크 스캔에 위치 권한 필요
- 프로그래밍 방식으로 연결/연결 해제 가능

## 문제 해결

### 일반적인 문제

**스캔 결과가 비어 있음**: 위치 권한이 부여되었는지 확인
**네트워크에 연결할 수 없음**: 비밀번호가 올바른지, 네트워크가 범위 내에 있는지 확인
**getWifiInfo 실패**: 기기가 WiFi 네트워크에 연결되어 있는지 확인
**권한 거부**: 플랫폼 구성 파일에 필요한 권한 추가
