---
title: Azure DevOps 통합
description: "앱 업데이트의 자동 배포를 위해 Capgo Live Updates를 Azure DevOps Pipelines와 통합하는 방법을 알아보세요."
sidebar:
  order: 1
locale: ko
---

import { Aside, Steps } from '@astrojs/starlight/components';

Capgo Live Updates를 Azure DevOps Pipelines와 통합하여 코드 변경 사항을 푸시할 때마다 앱 업데이트를 자동으로 배포하세요. 이 가이드는 자동화된 빌드, 테스트 및 배포 워크플로우 설정을 다룹니다.

## 사전 요구 사항

Azure DevOps 통합을 설정하기 전에 다음을 준비해야 합니다:

- Azure DevOps 조직 및 프로젝트
- 구성된 앱이 있는 Capgo 계정
- Azure Repos Git 저장소의 앱 소스 코드
- 프로젝트에 구성된 Node.js 및 npm/yarn

## Azure DevOps Pipeline 설정

### 1단계: Pipeline 변수 생성

먼저 Azure DevOps 프로젝트에 필요한 변수를 설정합니다:

<Steps>

1. Azure DevOps 프로젝트로 이동
2. **Pipelines** → **Library** → **Variable groups**로 이동
3. `Capgo-Variables`라는 새 변수 그룹 생성
4. 다음 변수 추가:

</Steps>

| 변수 이름 | 값 | Secure |
|---------------|-------|---------|
| `CAPGO_TOKEN` | Capgo API 토큰 | ✅ 예 |

<Aside type="tip">

[console.capgo.app/apikeys](https://console.capgo.app/apikeys)에서 Capgo API 토큰을 받으세요. 앱 ID는 이미 `capacitor.config.ts` 파일에 구성되어 있습니다.

</Aside>

## 간단한 구성

main 브랜치에 푸시할 때마다 프로덕션에 배포하는 기본 구성:

```yaml
# Capgo Live Updates를 위한 간단한 Azure DevOps Pipeline
trigger:
  branches:
    include:
      - main

variables:
  - group: Capgo-Variables

jobs:
  - job: BuildAndDeploy
    displayName: 'Build and Deploy to Capgo'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
      - task: NodeTool@0
        displayName: 'Setup Node.js'
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          npm install -g @capgo/cli
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production
        displayName: 'Deploy to Capgo'
```

## 고급 구성

### 기능 브랜치 배포

검토 및 테스트를 위해 기능 브랜치를 테스트 채널에 배포:

```yaml
# 기능 브랜치 배포
trigger:
  branches:
    include:
      - feature/*

variables:
  - group: Capgo-Variables

jobs:
  - job: DeployFeature
    displayName: 'Deploy Feature Branch'
    pool:
      vmImage: 'ubuntu-latest'
    condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')

    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9-]/-/g')
          CHANNEL_NAME="feature-$BRANCH_NAME"
          npm install -g @capgo/cli
          npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME
        displayName: 'Deploy to Feature Channel'
```

<Aside type="tip">

**채널로 테스트**: 기능 채널에 배포한 후 해당 특정 채널을 사용하도록 구성하여 앱에서 업데이트를 테스트할 수 있습니다. [앱에서 채널 구성](/docs/live-updates/channels/#configuring-the-channel-in-your-app)에 대해 자세히 알아보세요.

</Aside>

### 암호화 사용

[Capgo의 암호화 기능](/docs/live-updates/encryption/)을 사용하는 경우 CI/CD 환경에 개인 키를 안전하게 저장해야 합니다.

로컬에서 [암호화 키 설정](/docs/live-updates/encryption/#setting-up-encryption) 후 Azure DevOps 변수에 개인 키를 추가하세요:

```shell
# 개인 키 콘텐츠 표시(이 출력 복사)
cat .capgo_key_v2
```

이 콘텐츠를 Azure DevOps 변수 그룹에 `CAPGO_PRIVATE_KEY`로 추가(비밀로 표시)한 다음 파이프라인에서 사용:

```yaml
# 암호화로 배포
- script: |
    npm install -g @capgo/cli
    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --key-data-v2 "$(CAPGO_PRIVATE_KEY)" --channel production
  displayName: 'Deploy to Capgo with Encryption'
```

<Aside type="caution">

**보안 모범 사례:**
- `.capgo_key_v2` 파일을 절대 버전 관리에 커밋하지 마세요
- 개인 키는 안전한 CI/CD 비밀 관리에만 저장
- 다른 환경에 대해 다른 키 사용

</Aside>

### 다중 채널 구성

여러 배포 채널 설정 및 관리에 대한 포괄적인 정보는 [Channels 문서](/docs/live-updates/channels/)를 참조하세요.

여러 환경 및 풀 리퀘스트 배포가 포함된 완전한 구성:

```yaml
# 다중 채널이 있는 고급 Azure DevOps Pipeline
trigger:
  branches:
    include:
      - main
      - develop

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: Capgo-Variables

stages:
  # 빌드 단계
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  # 개발 환경에 배포
  - stage: DeployDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDevelopment
        environment: development
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel development --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Development'

  # PR을 테스트 채널에 배포
  - stage: DeployPR
    condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: DeployPRChannel
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - task: DownloadBuildArtifacts@0
            inputs:
              artifactName: 'app-build'
              downloadPath: '$(Pipeline.Workspace)'

          - script: |
              CHANNEL_NAME="pr-$(System.PullRequest.PullRequestNumber)"
              npm install -g @capgo/cli
              npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
              npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME --path $(Pipeline.Workspace)/app-build
            displayName: 'Deploy to PR Channel'

  # 프로덕션에 배포
  - stage: DeployProd
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        environment: production
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Production'
```

### 다중 환경 배포

여러 환경이 있는 복잡한 시나리오의 경우:

```yaml
# 다중 환경이 있는 확장 파이프라인
parameters:
  - name: deployEnvironment
    displayName: 'Deploy Environment'
    type: string
    default: 'staging'
    values:
      - staging
      - production

variables:
  - group: Capgo-Variables
  - name: channelName
    ${{ if eq(parameters.deployEnvironment, 'production') }}:
      value: 'production'
    ${{ else }}:
      value: 'staging'

stages:
  # 빌드 단계
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'staging'))
    jobs:
      - deployment: DeployStaging
        displayName: 'Deploy to Staging Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'staging'

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'production'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'production'
```

### 배포 템플릿 (deploy-steps.yml)

재사용 가능한 템플릿 파일 `deploy-steps.yml` 생성:

```yaml
# deploy-steps.yml
parameters:
  - name: channel
    type: string

steps:
  - task: NodeTool@0
    displayName: 'Install Node.js'
    inputs:
      versionSpec: '22.x'

  - task: DownloadBuildArtifacts@0
    displayName: 'Download build artifacts'
    inputs:
      artifactName: 'app-build'
      downloadPath: '$(System.ArtifactsDirectory)'

  - script: |
      npm install -g @capgo/cli
    displayName: 'Install Capgo CLI'

  - script: |
      npx @capgo/cli bundle upload \
        --apikey $(CAPGO_TOKEN) \
        --channel ${{ parameters.channel }} \
        --path $(System.ArtifactsDirectory)/app-build
    displayName: 'Upload to Capgo (${{ parameters.channel }})'
```

### 브랜치 기반 배포 전략

Git 브랜치에 따라 다른 배포 전략 구성:

```yaml
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*

variables:
  - group: Capgo-Variables
  - name: targetChannel
    ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
      value: 'production'
    ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
      value: 'staging'
    ${{ else }}:
      value: 'development'

stages:
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: Deploy
    displayName: 'Deploy to $(targetChannel)'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy to $(targetChannel) Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: '$(targetChannel)'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: '$(targetChannel)'
```

## 보안 모범 사례

### 안전한 변수 관리

<Steps>

1. **변수 그룹 사용**: 민감한 데이터를 Azure DevOps 변수 그룹에 저장
2. **비밀로 표시**: API 토큰 및 키를 항상 비밀 변수로 표시
3. **액세스 범위 지정**: 특정 파이프라인 및 사용자로 변수 그룹 액세스 제한
4. **키 교체**: Capgo API 토큰을 정기적으로 교체

</Steps>

## 모니터링 및 알림

### Teams 통합

파이프라인에 Microsoft Teams 알림 추가:

```yaml
- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Success'
  condition: succeeded()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Successful'
    text: 'App deployed to $(targetChannel) channel'
    themeColor: '00FF00'

- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Failure'
  condition: failed()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Failed'
    text: 'Deployment to $(targetChannel) failed'
    themeColor: 'FF0000'
```

### 이메일 알림

배포 상태에 대한 이메일 알림 구성:

```yaml
- task: EmailReport@1
  displayName: 'Send Email Report'
  condition: always()
  inputs:
    sendMailConditionConfig: 'Always'
    subject: 'Capgo Deployment Report - $(Build.BuildNumber)'
    to: 'team@yourcompany.com'
    body: |
      Deployment Status: $(Agent.JobStatus)
      Channel: $(targetChannel)
      Build: $(Build.BuildNumber)
      Commit: $(Build.SourceVersion)
```

## 문제 해결

### 일반적인 문제

**"Capgo CLI not found"로 파이프라인 실패:**
```yaml
# 전역 설치 보장
- script: |
    npm install -g @capgo/cli
    which capgo || echo "Capgo CLI not found in PATH"
  displayName: 'Install and verify Capgo CLI'
```

**인증 오류:**
```yaml
# 토큰이 올바르게 설정되었는지 확인
- script: |
    echo "Token length: ${#CAPGO_TOKEN}"
    if [ -z "$CAPGO_TOKEN" ]; then
      echo "CAPGO_TOKEN is not set"
      exit 1
    fi
  displayName: 'Verify Capgo token'
  env:
    CAPGO_TOKEN: $(CAPGO_TOKEN)
```

**빌드 아티팩트를 찾을 수 없음:**
```yaml
# 디버깅을 위해 사용 가능한 아티팩트 나열
- script: |
    ls -la $(System.ArtifactsDirectory)
    find $(System.ArtifactsDirectory) -name "*.js" -o -name "*.html"
  displayName: 'Debug artifacts'
```

### 파이프라인 디버그

문제를 해결하기 위한 디버깅 단계 추가:

```yaml
- script: |
    echo "Build.SourceBranch: $(Build.SourceBranch)"
    echo "Build.BuildNumber: $(Build.BuildNumber)"
    echo "Target Channel: $(targetChannel)"
  displayName: 'Debug Pipeline Variables'

- script: |
    npx @capgo/cli app debug --apikey $(CAPGO_TOKEN)
  displayName: 'Debug Capgo App Status'
```

## 다음 단계

- 다양한 배포 환경을 관리하려면 [Channels](/docs/live-updates/channels/)에 대해 알아보기
- 고급 배포 시나리오를 위해 [Custom Storage](/docs/live-updates/custom-storage/) 살펴보기
- 안전한 배포를 위해 [Encryption](/docs/live-updates/encryption/) 설정
- 업데이트 적용 방법을 사용자 정의하기 위해 [Update Behavior](/docs/live-updates/update-behavior/) 구성

Azure DevOps 통합을 통해 Capgo 배포를 자동화하고 모바일 앱 사용자에게 일관되고 안정적인 업데이트를 보장할 수 있습니다.
