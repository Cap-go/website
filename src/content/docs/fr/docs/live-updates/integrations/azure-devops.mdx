---
title: Intégration Azure DevOps
description: "Apprenez comment intégrer Capgo Live Updates avec Azure DevOps Pipelines pour le déploiement automatisé de vos mises à jour d'application."
locale: fr
sidebar:
  order: 1
---

import { Aside, Steps } from '@astrojs/starlight/components';

Intégrez Capgo Live Updates avec Azure DevOps Pipelines pour déployer automatiquement vos mises à jour d'application à chaque fois que vous poussez des modifications de code. Ce guide couvre la configuration des workflows de build, de test et de déploiement automatisés.

## Prérequis

Avant de configurer l'intégration Azure DevOps, assurez-vous d'avoir :

- Une organisation et un projet Azure DevOps
- Un compte Capgo avec une application configurée
- Le code source de votre application dans un référentiel Git Azure Repos
- Node.js et npm/yarn configurés dans votre projet

## Configuration du pipeline Azure DevOps

### Étape 1 : Créer des variables de pipeline

Tout d'abord, configurez les variables nécessaires dans votre projet Azure DevOps :

<Steps>

1. Accédez à votre projet Azure DevOps
2. Allez dans **Pipelines** → **Library** → **Variable groups**
3. Créez un nouveau groupe de variables nommé `Capgo-Variables`
4. Ajoutez les variables suivantes :

</Steps>

| Nom de variable | Valeur | Sécurisé |
|---------------|-------|---------|
| `CAPGO_TOKEN` | Votre jeton API Capgo | ✅ Oui |

<Aside type="tip">

Obtenez votre jeton API Capgo depuis [console.capgo.app/apikeys](https://console.capgo.app/apikeys). L'ID de votre application est déjà configuré dans votre fichier `capacitor.config.ts`.

</Aside>

## Simple

Configuration de base qui déploie en production à chaque push vers la branche main :

```yaml
# Simple Azure DevOps Pipeline pour Capgo Live Updates
trigger:
  branches:
    include:
      - main

variables:
  - group: Capgo-Variables

jobs:
  - job: BuildAndDeploy
    displayName: 'Build and Deploy to Capgo'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
      - task: NodeTool@0
        displayName: 'Setup Node.js'
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          npm install -g @capgo/cli
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production
        displayName: 'Deploy to Capgo'
```

## Avancé

### Déploiements de branches de fonctionnalités

Déployez les branches de fonctionnalités vers des canaux de test pour révision et test :

```yaml
# Déploiement de branche de fonctionnalité
trigger:
  branches:
    include:
      - feature/*

variables:
  - group: Capgo-Variables

jobs:
  - job: DeployFeature
    displayName: 'Deploy Feature Branch'
    pool:
      vmImage: 'ubuntu-latest'
    condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')

    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9-]/-/g')
          CHANNEL_NAME="feature-$BRANCH_NAME"
          npm install -g @capgo/cli
          npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME
        displayName: 'Deploy to Feature Channel'
```

<Aside type="tip">

**Tests avec les canaux** : Après le déploiement vers un canal de fonctionnalité, vous pouvez tester la mise à jour dans votre application en la configurant pour utiliser ce canal spécifique. En savoir plus sur [la configuration des canaux dans votre application](/docs/live-updates/channels/#configuring-the-channel-in-your-app).

</Aside>

### Utilisation du chiffrement

Si vous utilisez [la fonctionnalité de chiffrement de Capgo](/docs/live-updates/encryption/), vous devrez stocker votre clé privée en toute sécurité dans votre environnement CI/CD.

Après avoir [configuré les clés de chiffrement](/docs/live-updates/encryption/#setting-up-encryption) localement, ajoutez votre clé privée aux variables Azure DevOps :

```shell
# Afficher le contenu de votre clé privée (copiez cette sortie)
cat .capgo_key_v2
```

Ajoutez ce contenu en tant que `CAPGO_PRIVATE_KEY` dans votre groupe de variables Azure DevOps (marquez comme secret), puis utilisez-le dans les pipelines :

```yaml
# Déployer avec chiffrement
- script: |
    npm install -g @capgo/cli
    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --key-data-v2 "$(CAPGO_PRIVATE_KEY)" --channel production
  displayName: 'Deploy to Capgo with Encryption'
```

<Aside type="caution">

**Meilleures pratiques de sécurité :**
- Ne jamais valider le fichier `.capgo_key_v2` dans le contrôle de version
- Stocker la clé privée uniquement dans la gestion sécurisée des secrets CI/CD
- Utiliser des clés différentes pour différents environnements

</Aside>

### Configuration multi-canaux

Pour des informations complètes sur la configuration et la gestion de plusieurs canaux de déploiement, consultez la [documentation sur les canaux](/docs/live-updates/channels/).

Configuration complète avec plusieurs environnements et déploiements de pull request :

```yaml
# Pipeline Azure DevOps avancé avec plusieurs canaux
trigger:
  branches:
    include:
      - main
      - develop

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: Capgo-Variables

stages:
  # Étape de build
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  # Déployer en développement
  - stage: DeployDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDevelopment
        environment: development
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel development --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Development'

  # Déployer PR vers canal de test
  - stage: DeployPR
    condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: DeployPRChannel
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - task: DownloadBuildArtifacts@0
            inputs:
              artifactName: 'app-build'
              downloadPath: '$(Pipeline.Workspace)'

          - script: |
              CHANNEL_NAME="pr-$(System.PullRequest.PullRequestNumber)"
              npm install -g @capgo/cli
              npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
              npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME --path $(Pipeline.Workspace)/app-build
            displayName: 'Deploy to PR Channel'

  # Déployer en production
  - stage: DeployProd
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        environment: production
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Production'
```

### Déploiement multi-environnements

Pour des scénarios complexes avec plusieurs environnements :

```yaml
# Pipeline étendu avec plusieurs environnements
parameters:
  - name: deployEnvironment
    displayName: 'Deploy Environment'
    type: string
    default: 'staging'
    values:
      - staging
      - production

variables:
  - group: Capgo-Variables
  - name: channelName
    ${{ if eq(parameters.deployEnvironment, 'production') }}:
      value: 'production'
    ${{ else }}:
      value: 'staging'

stages:
  # Étape de build
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'staging'))
    jobs:
      - deployment: DeployStaging
        displayName: 'Deploy to Staging Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'staging'

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'production'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'production'
```

### Modèle de déploiement (deploy-steps.yml)

Créez un fichier de modèle réutilisable `deploy-steps.yml` :

```yaml
# deploy-steps.yml
parameters:
  - name: channel
    type: string

steps:
  - task: NodeTool@0
    displayName: 'Install Node.js'
    inputs:
      versionSpec: '22.x'

  - task: DownloadBuildArtifacts@0
    displayName: 'Download build artifacts'
    inputs:
      artifactName: 'app-build'
      downloadPath: '$(System.ArtifactsDirectory)'

  - script: |
      npm install -g @capgo/cli
    displayName: 'Install Capgo CLI'

  - script: |
      npx @capgo/cli bundle upload \
        --apikey $(CAPGO_TOKEN) \
        --channel ${{ parameters.channel }} \
        --path $(System.ArtifactsDirectory)/app-build
    displayName: 'Upload to Capgo (${{ parameters.channel }})'
```

### Stratégie de déploiement basée sur les branches

Configurez différentes stratégies de déploiement basées sur les branches Git :

```yaml
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*

variables:
  - group: Capgo-Variables
  - name: targetChannel
    ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
      value: 'production'
    ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
      value: 'staging'
    ${{ else }}:
      value: 'development'

stages:
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: Deploy
    displayName: 'Deploy to $(targetChannel)'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy to $(targetChannel) Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: '$(targetChannel)'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: '$(targetChannel)'
```

## Meilleures pratiques de sécurité

### Gestion sécurisée des variables

<Steps>

1. **Utiliser des groupes de variables** : Stocker les données sensibles dans des groupes de variables Azure DevOps
2. **Marquer comme secret** : Toujours marquer les jetons API et les clés comme variables secrètes
3. **Limiter l'accès** : Limiter l'accès aux groupes de variables à des pipelines et utilisateurs spécifiques
4. **Rotation des clés** : Effectuer régulièrement la rotation de vos jetons API Capgo

</Steps>

## Surveillance et notifications

### Intégration Teams

Ajoutez des notifications Microsoft Teams à votre pipeline :

```yaml
- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Success'
  condition: succeeded()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Successful'
    text: 'App deployed to $(targetChannel) channel'
    themeColor: '00FF00'

- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Failure'
  condition: failed()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Failed'
    text: 'Deployment to $(targetChannel) failed'
    themeColor: 'FF0000'
```

### Notifications par e-mail

Configurez les notifications par e-mail pour le statut de déploiement :

```yaml
- task: EmailReport@1
  displayName: 'Send Email Report'
  condition: always()
  inputs:
    sendMailConditionConfig: 'Always'
    subject: 'Capgo Deployment Report - $(Build.BuildNumber)'
    to: 'team@yourcompany.com'
    body: |
      Deployment Status: $(Agent.JobStatus)
      Channel: $(targetChannel)
      Build: $(Build.BuildNumber)
      Commit: $(Build.SourceVersion)
```

## Dépannage

### Problèmes courants

**Le pipeline échoue avec "Capgo CLI not found" :**
```yaml
# Assurer l'installation globale
- script: |
    npm install -g @capgo/cli
    which capgo || echo "Capgo CLI not found in PATH"
  displayName: 'Install and verify Capgo CLI'
```

**Erreurs d'authentification :**
```yaml
# Vérifier que le jeton est correctement défini
- script: |
    echo "Token length: ${#CAPGO_TOKEN}"
    if [ -z "$CAPGO_TOKEN" ]; then
      echo "CAPGO_TOKEN is not set"
      exit 1
    fi
  displayName: 'Verify Capgo token'
  env:
    CAPGO_TOKEN: $(CAPGO_TOKEN)
```

**Artefacts de build introuvables :**
```yaml
# Lister les artefacts disponibles pour le débogage
- script: |
    ls -la $(System.ArtifactsDirectory)
    find $(System.ArtifactsDirectory) -name "*.js" -o -name "*.html"
  displayName: 'Debug artifacts'
```

### Pipeline de débogage

Ajoutez des étapes de débogage pour résoudre les problèmes :

```yaml
- script: |
    echo "Build.SourceBranch: $(Build.SourceBranch)"
    echo "Build.BuildNumber: $(Build.BuildNumber)"
    echo "Target Channel: $(targetChannel)"
  displayName: 'Debug Pipeline Variables'

- script: |
    npx @capgo/cli app debug --apikey $(CAPGO_TOKEN)
  displayName: 'Debug Capgo App Status'
```

## Prochaines étapes

- Découvrez les [Canaux](/docs/live-updates/channels/) pour gérer différents environnements de déploiement
- Explorez le [Stockage personnalisé](/docs/live-updates/custom-storage/) pour des scénarios de déploiement avancés
- Configurez le [Chiffrement](/docs/live-updates/encryption/) pour des déploiements sécurisés
- Configurez le [Comportement des mises à jour](/docs/live-updates/update-behavior/) pour personnaliser l'application des mises à jour

Avec l'intégration Azure DevOps, vous pouvez automatiser vos déploiements Capgo et garantir des mises à jour cohérentes et fiables pour les utilisateurs de votre application mobile.
