---
title: Intégration GitLab CI/CD
description: "Apprenez comment intégrer Capgo Live Updates avec GitLab CI/CD pour le déploiement automatisé de vos mises à jour d'application."
locale: fr
sidebar:
  order: 2
---

import { Aside, Steps } from '@astrojs/starlight/components';

Intégrez Capgo Live Updates avec GitLab CI/CD pour déployer automatiquement vos mises à jour d'application à chaque fois que vous poussez des modifications de code. Ce guide couvre la configuration des workflows de build, de test et de déploiement automatisés.

## Prérequis

Avant de configurer l'intégration GitLab CI/CD, assurez-vous d'avoir :

- Un compte GitLab avec un référentiel de projet
- Un compte Capgo avec une application configurée
- Node.js et npm/yarn configurés dans votre projet

## Configuration de GitLab CI/CD

### Étape 1 : Configurer les variables d'environnement

Tout d'abord, configurez les variables nécessaires dans votre projet GitLab :

<Steps>

1. Accédez à votre projet GitLab
2. Allez dans **Settings** → **CI/CD** → **Variables**
3. Ajoutez les variables suivantes :

</Steps>

| Nom de variable | Valeur | Protégé | Masqué |
|---------------|-------|-----------|--------|
| `CAPGO_TOKEN` | Votre jeton API Capgo | ✅ Oui | ✅ Oui |

<Aside type="tip">

Obtenez votre jeton API Capgo depuis [console.capgo.app/apikeys](https://console.capgo.app/apikeys). L'ID de votre application est déjà configuré dans votre fichier `capacitor.config.ts`.

</Aside>

## Simple

Configuration de base qui déploie en production à chaque push vers la branche main :

```yaml
# .gitlab-ci.yml - Configuration simple
image: node:22

stages:
  - build
  - deploy

variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"

build:
  stage: build
  script:
    - npm ci
    - npm run test
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 1 hour
  only:
    - main

deploy_production:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel production
    # For encrypted uploads, add: --key-data-v2 "$CAPGO_PRIVATE_KEY"
  dependencies:
    - build
  only:
    - main
```

## Avancé

### Déploiements de branches de fonctionnalités

Déployez les branches de fonctionnalités vers des canaux de test pour révision et test :

```yaml
# Déploiement de branche de fonctionnalité
deploy_feature:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - CHANNEL_NAME="feature-$(echo $CI_COMMIT_REF_NAME | sed 's/[^a-zA-Z0-9-]/-/g')"
    - npx @capgo/cli channel create $CHANNEL_NAME --apikey $CAPGO_TOKEN || true
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel $CHANNEL_NAME
  dependencies:
    - build
  only:
    - /^feature\/.*$/
  environment:
    name: feature/$CI_COMMIT_REF_NAME
    url: https://your-app.com/channels/$CHANNEL_NAME
```

<Aside type="tip">

**Tests avec les canaux** : Après le déploiement vers un canal de fonctionnalité, vous pouvez tester la mise à jour dans votre application en la configurant pour utiliser ce canal spécifique. En savoir plus sur [la configuration des canaux dans votre application](/docs/live-updates/channels/#configuring-the-channel-in-your-app).

</Aside>

### Utilisation du chiffrement

Si vous utilisez [la fonctionnalité de chiffrement de Capgo](/docs/live-updates/encryption/), vous devrez stocker votre clé privée en toute sécurité dans votre environnement CI/CD.

Après avoir [configuré les clés de chiffrement](/docs/live-updates/encryption/#setting-up-encryption) localement, ajoutez votre clé privée aux variables GitLab :

```shell
# Afficher le contenu de votre clé privée (copiez cette sortie)
cat .capgo_key_v2
```

Ajoutez ce contenu en tant que `CAPGO_PRIVATE_KEY` dans les variables de votre projet GitLab (marquez comme protégé et masqué), puis utilisez-le dans les pipelines :

```yaml
# Déployer avec chiffrement
deploy_production:
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --key-data-v2 "$CAPGO_PRIVATE_KEY" --channel production
```

<Aside type="caution">

**Meilleures pratiques de sécurité :**
- Ne jamais valider le fichier `.capgo_key_v2` dans le contrôle de version
- Stocker la clé privée uniquement dans la gestion sécurisée des secrets CI/CD
- Utiliser des clés différentes pour différents environnements

</Aside>

### Configuration multi-canaux

Pour des informations complètes sur la configuration et la gestion de plusieurs canaux de déploiement, consultez la [documentation sur les canaux](/docs/live-updates/channels/).

Configuration complète avec plusieurs environnements et déploiements de merge request :

```yaml
# .gitlab-ci.yml - Configuration multi-canaux avancée
image: node:22

stages:
  - build
  - deploy

variables:
  npm_config_cache: "$CI_PROJECT_DIR/.npm"

# Étape de build
build:
  stage: build
  script:
    - npm ci
    - npm run test
    - npm run build
  artifacts:
    paths:
      - dist/
    expire_in: 24 hours

# Déployer vers le canal de développement
deploy_development:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel development
  dependencies:
    - build
  only:
    - develop
  environment:
    name: development

# Déployer les merge requests vers des canaux de test
deploy_mr:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - CHANNEL_NAME="mr-$CI_MERGE_REQUEST_IID"
    - npx @capgo/cli channel create $CHANNEL_NAME --apikey $CAPGO_TOKEN || true
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel $CHANNEL_NAME
  dependencies:
    - build
  only:
    - merge_requests
  environment:
    name: review/$CI_MERGE_REQUEST_IID
    url: https://your-app.com/channels/mr-$CI_MERGE_REQUEST_IID
    on_stop: cleanup_mr

# Nettoyer les canaux MR lorsque la MR est fermée
cleanup_mr:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli channel delete mr-$CI_MERGE_REQUEST_IID --apikey $CAPGO_TOKEN || true
  when: manual
  environment:
    name: review/$CI_MERGE_REQUEST_IID
    action: stop
  only:
    - merge_requests

# Déployer vers staging
deploy_staging:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel staging
  dependencies:
    - build
  only:
    - develop
  environment:
    name: staging

# Déployer vers production
deploy_production:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel production
  dependencies:
    - build
  only:
    - main
  environment:
    name: production
```

### Multi-environnements avec approbation manuelle

Pour les déploiements de production nécessitant une approbation manuelle :

```yaml
deploy_production:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel production
  dependencies:
    - build
  only:
    - main
  when: manual
  environment:
    name: production
```

### Stratégie de déploiement basée sur les branches

Déployer automatiquement différentes branches vers les canaux appropriés :

```yaml
# Déploiement dynamique de canal basé sur la branche
deploy:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - |
      if [ "$CI_COMMIT_REF_NAME" = "main" ]; then
        CHANNEL="production"
      elif [ "$CI_COMMIT_REF_NAME" = "develop" ]; then
        CHANNEL="staging"
      else
        CHANNEL="development"
      fi
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel $CHANNEL
  dependencies:
    - build
  environment:
    name: $CHANNEL
```

## Meilleures pratiques de sécurité

### Variables protégées

<Steps>

1. **Marquer les variables sensibles** : Toujours marquer les jetons API comme protégés et masqués
2. **Protection des branches** : Utiliser des variables protégées pour les déploiements de production
3. **Contrôle d'accès** : Limiter l'accès aux variables aux mainteneurs uniquement
4. **Rotation régulière** : Effectuer régulièrement la rotation des jetons API

</Steps>

### Configuration sécurisée du pipeline

```yaml
# Utiliser des variables protégées pour la production
deploy_production:
  stage: deploy
  script:
    - npm install -g @capgo/cli
    - npx @capgo/cli bundle upload --apikey $CAPGO_TOKEN --channel production
  only:
    refs:
      - main
    variables:
      - $CI_COMMIT_REF_PROTECTED == "true"
```

## Surveillance et notifications

### Intégration Slack

Ajoutez des notifications Slack à votre pipeline :

```yaml
notify_success:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"✅ Capgo deployment successful for '"$CI_COMMIT_REF_NAME"'"}' \
        $SLACK_WEBHOOK_URL
  when: on_success

notify_failure:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \
        --data '{"text":"❌ Capgo deployment failed for '"$CI_COMMIT_REF_NAME"'"}' \
        $SLACK_WEBHOOK_URL
  when: on_failure
```

### Notifications par e-mail

Configurez les notifications par e-mail dans les paramètres de votre projet GitLab ou utilisez l'API :

```yaml
notify_email:
  stage: .post
  script:
    - |
      curl --request POST \
        --header "PRIVATE-TOKEN: $GITLAB_API_TOKEN" \
        --form "to=team@yourcompany.com" \
        --form "subject=Capgo Deployment Status" \
        --form "body=Deployment of $CI_COMMIT_REF_NAME completed with status: $CI_JOB_STATUS" \
        "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/emails"
  when: always
```

## Dépannage

### Problèmes courants

**Le pipeline échoue avec "Capgo CLI not found" :**
```yaml
# Déboguer l'installation du CLI
debug_cli:
  script:
    - npm install -g @capgo/cli
    - which capgo || echo "Capgo CLI not found"
    - npx @capgo/cli --version
```

**Erreurs d'authentification :**
```yaml
# Vérifier la configuration du jeton
debug_auth:
  script:
    - |
      if [ -z "$CAPGO_TOKEN" ]; then
        echo "CAPGO_TOKEN is not set"
        exit 1
      fi
      echo "Token length: ${#CAPGO_TOKEN}"
```

**Artefacts de build introuvables :**
```yaml
# Lister les sorties de build
debug_build:
  script:
    - ls -la dist/
    - find dist/ -type f -name "*.js" -o -name "*.html"
```

### Pipeline de débogage

Ajoutez des informations de débogage pour résoudre les problèmes :

```yaml
debug:
  stage: build
  script:
    - echo "Branch: $CI_COMMIT_REF_NAME"
    - echo "Commit: $CI_COMMIT_SHA"
    - echo "Build: $CI_PIPELINE_ID"
    - env | grep CI_ | sort
  only:
    - branches
```

## Prochaines étapes

- Découvrez les [Canaux](/docs/live-updates/channels/) pour gérer différents environnements de déploiement
- Explorez le [Stockage personnalisé](/docs/live-updates/custom-storage/) pour des scénarios de déploiement avancés
- Configurez le [Chiffrement](/docs/live-updates/encryption/) pour des déploiements sécurisés
- Configurez le [Comportement des mises à jour](/docs/live-updates/update-behavior/) pour personnaliser l'application des mises à jour

Avec l'intégration GitLab CI/CD, vous pouvez automatiser vos déploiements Capgo et garantir des mises à jour cohérentes et fiables pour les utilisateurs de votre application mobile.
