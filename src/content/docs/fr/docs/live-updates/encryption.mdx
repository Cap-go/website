---
title: Chiffrement
description: "Découvrez comment le chiffrement de bout en bout de Capgo sécurise vos bundles d'application pendant la transmission et le stockage, protégeant votre code et les données utilisateur."
locale: fr
sidebar:
  order: 5
---

import { Aside, Steps } from '@astrojs/starlight/components';

Capgo fournit un chiffrement de bout en bout robuste pour vos bundles d'application, garantissant que votre code JavaScript et vos ressources sont protégés pendant la transmission et le stockage. Ce système de chiffrement est conçu pour vous donner un contrôle total sur la sécurité de votre application tout en maintenant la commodité des mises à jour en direct.

## Aperçu

Le système de chiffrement de Capgo utilise des méthodes cryptographiques standard de l'industrie pour protéger vos bundles contre les accès non autorisés. Lorsque le chiffrement est activé, vos bundles sont chiffrés avant de quitter votre environnement de développement et restent chiffrés jusqu'à ce qu'ils soient déchiffrés par votre application sur l'appareil de l'utilisateur.

**Véritable chiffrement de bout en bout** : Contrairement à d'autres plateformes de mise à jour OTA qui ne signent que les mises à jour (laissant le code publiquement lisible), Capgo fournit un véritable chiffrement de bout en bout. Cela signifie que seuls vos utilisateurs peuvent déchiffrer vos mises à jour - personne d'autre, y compris Capgo lui-même. Le contenu de votre bundle reste complètement privé et illisible tout au long du processus de livraison.

<Aside type="tip">

Le chiffrement est particulièrement important pour :
- Les applications traitant des données sensibles ou de la logique métier
- Les applications d'entreprise avec des exigences de conformité
- Les applications déployées dans des industries réglementées
- Les organisations ayant des politiques de sécurité strictes

</Aside>

## Comment fonctionne le chiffrement

Capgo utilise une approche de chiffrement hybride qui combine le chiffrement RSA et AES pour une sécurité et des performances optimales :

![Flux de chiffrement Capgo](/encryption_flow.webp)

### 1. Génération de clés
- **Clé privée** : Générée et stockée en toute sécurité dans votre environnement de développement (utilisée pour le chiffrement)
- **Clé publique** : Dérivée de votre clé privée et stockée dans la configuration Capacitor de votre application (utilisée pour le déchiffrement)
- **Clés de session** : Clés AES aléatoires générées pour chaque téléchargement de bundle

### 2. Processus de chiffrement
1. Une clé de session AES aléatoire est générée pour chaque téléchargement de bundle
2. Votre bundle est chiffré à l'aide de la clé de session AES
3. La somme de contrôle du bundle est calculée
4. La clé de session AES et la somme de contrôle sont chiffrées ensemble à l'aide de votre clé privée RSA (créant la "signature")
5. Le bundle chiffré et la signature chiffrée sont stockés

La somme de contrôle est chiffrée aux côtés de la clé AES pour empêcher la falsification. Étant donné que seule votre clé privée RSA peut créer cette signature, et que seule la clé publique correspondante peut la déchiffrer, cela garantit que la clé de session AES et la somme de contrôle attendue sont authentiques et n'ont pas été modifiées par un attaquant.

### 3. Processus de déchiffrement
1. Votre application télécharge le bundle chiffré et la signature chiffrée
2. Le SDK Capgo utilise votre clé publique RSA (stockée dans l'application) pour déchiffrer la signature
3. Cela révèle la clé de session AES et la somme de contrôle d'origine
4. La clé de session AES est utilisée pour déchiffrer le bundle
5. Une somme de contrôle du bundle déchiffré est calculée et comparée à la somme de contrôle d'origine pour la vérification de l'intégrité

Ce processus garantit que même si un attaquant intercepte le bundle chiffré, il ne peut pas modifier la clé de session AES ou fournir une fausse somme de contrôle, car il aurait besoin de votre clé privée pour créer une signature valide que la clé publique peut déchiffrer.

<Aside type="tip">

RSA ne peut pas chiffrer efficacement de grandes quantités de données, donc AES est utilisé pour le chiffrement réel du bundle tandis que RSA sécurise la clé AES et fournit une vérification d'intégrité par signature de somme de contrôle.

</Aside>

## Capgo vs autres plateformes

| Fonctionnalité | Capgo | Autres plateformes OTA |
|---------|-------|-------------------|
| **Contenu du bundle** | Entièrement chiffré (illisible) | Publiquement lisible |
| **Méthode de sécurité** | Véritable chiffrement de bout en bout | Signature de code uniquement |
| **Niveau de confidentialité** | Zéro connaissance (même Capgo ne peut pas lire votre code) | La plateforme peut accéder à votre code |
| **Protection** | Contenu + intégrité + authenticité | Intégrité + authenticité uniquement |

**Pourquoi c'est important :**
- **La signature de code** vérifie uniquement que les mises à jour n'ont pas été falsifiées et proviennent de la bonne source
- **Le chiffrement de bout en bout** garantit que le contenu réel de votre code reste privé et illisible pendant la transmission et le stockage
- Avec le véritable chiffrement de bout en bout de Capgo, seuls vos utilisateurs peuvent déchiffrer les mises à jour - personne d'autre, y compris Capgo lui-même

## Méthodes de chiffrement

Capgo utilise le chiffrement V2 comme méthode de chiffrement standard :

### Chiffrement V2 (norme actuelle)
- Utilise RSA-4096 pour une sécurité renforcée
- AES-256-GCM pour un chiffrement authentifié
- Fournit une vérification d'intégrité
- Meilleures performances et sécurité

### Chiffrement V1 (obsolète)
- Utilise RSA-2048 pour le chiffrement de clé
- AES-256-CBC pour le chiffrement de bundle
- **Plus disponible dans le CLI actuel**
- Les applications héritées utilisant V1 doivent migrer vers V2

<Aside type="danger">

Le chiffrement V1 n'est plus pris en charge dans le CLI Capgo actuel. Si vous utilisez le chiffrement V1, vous devez migrer vers V2. Consultez le [guide de migration](/docs/upgrade/encryption-v1-to-v2/) pour des instructions détaillées.

</Aside>

## Configuration du chiffrement

### Étape 1 : Générer les clés de chiffrement

Tout d'abord, générez vos clés de chiffrement à l'aide du CLI Capgo :

```shell
# Générer de nouvelles clés de chiffrement (crée des fichiers dans le répertoire actuel)
npx @capgo/cli@latest key create
```

Cela crée :
- `.capgo_key_v2` : Votre clé privée (gardez-la en sécurité !)
- `.capgo_key_v2.pub` : Votre clé publique (utilisée par votre application)

Ces fichiers sont créés dans le répertoire actuel où vous exécutez la commande.

<Aside type="caution">

**Notes importantes sur le stockage :**
- **Clé privée (`.capgo_key_v2`)** : Ne jamais valider ceci dans le contrôle de version. Ce fichier doit être gardé en sécurité et utilisé uniquement pour le chiffrement lors des téléchargements de bundle.
- **Clé publique (`.capgo_key_v2.pub`)** : Celle-ci est sûre à valider dans le contrôle de version car c'est une sauvegarde de votre clé publique.
- **Emplacement du fichier** : Les clés sont créées dans le répertoire actuel où vous exécutez la commande `key create`.
- **Clé publique dans la configuration** : Vous devez exécuter `key save` pour stocker la clé publique dans votre configuration Capacitor afin que l'application mobile puisse l'utiliser.

Pour une utilisation en production, stockez la clé privée en toute sécurité (variables d'environnement, services de gestion de clés) et supprimez-la de votre projet local après la configuration.

</Aside>

### Étape 2 : Enregistrer votre clé publique dans la configuration Capacitor (requis)

Vous **devez** enregistrer votre clé publique dans la configuration Capacitor afin que votre application mobile puisse déchiffrer les bundles :

```shell
# Enregistrer la clé publique du fichier vers la configuration Capacitor (requis)
npx @capgo/cli@latest key save --key ./.capgo_key_v2.pub

# Ou enregistrer les données de clé publique directement
npx @capgo/cli@latest key save --key-data "$CAPGO_PUBLIC_KEY"
```

### Étape 3 : Synchroniser la plateforme Capacitor (requis)

Après avoir enregistré la clé publique, vous **devez** synchroniser la plateforme Capacitor pour copier la configuration mise à jour vers la couche native :

```shell
# Synchroniser la plateforme pour copier la configuration vers le natif
npx cap sync
```

<Aside type="caution">

**Étapes requises** :
1. La commande `key save` stocke la clé publique dans votre configuration Capacitor
2. `npx cap sync` copie cette configuration vers la couche native où l'application mobile peut y accéder
3. Sans ces deux étapes, votre application ne pourra pas déchiffrer les mises à jour chiffrées

</Aside>

## Chiffrement des bundles

### Méthode 1 : Chiffrer pendant le téléchargement

La façon la plus simple est de chiffrer pendant le processus de téléchargement :

```shell
# Télécharger avec chiffrement automatique
npx @capgo/cli@latest bundle upload --key-v2

# Pour le stockage externe, vous devez chiffrer d'abord (voir Flux de travail de chiffrement manuel ci-dessous)
```

### Méthode 2 : Flux de travail de chiffrement manuel

Pour plus de contrôle, vous pouvez chiffrer manuellement les bundles :

<Steps>

1. **Créer un bundle zip :**
   ```shell
   npx @capgo/cli@latest bundle zip com.example.app --path ./dist --key-v2
   ```

2. **Chiffrer le bundle :**
   ```shell
   npx @capgo/cli@latest bundle encrypt ./com.example.app.zip CHECKSUM_FROM_STEP_1
   ```

3. **Télécharger vers votre stockage (par ex., S3) et enregistrer avec Capgo :**
   ```shell
   # D'abord télécharger le bundle chiffré vers votre stockage (par ex., AWS S3)
   aws s3 cp ./encrypted-bundle.zip s3://your-bucket/encrypted-bundle.zip

   # Puis enregistrer avec Capgo en utilisant l'URL externe
   npx @capgo/cli@latest bundle upload --external https://your-storage.com/encrypted-bundle.zip --iv-session-key IV_SESSION_KEY_FROM_STEP_2
   ```

</Steps>

## Gestion des clés

### Stockage sécurisé des clés

**Options de clé privée :**

1. **Basé sur fichier (développement local) :**
   ```shell
   # Clé stockée en tant que fichier .capgo_key_v2 dans la racine du projet
   npx @capgo/cli@latest bundle upload --key-v2
   ```

2. **Variable d'environnement (CI/CD) :**
   ```shell
   # Stocker dans une variable d'environnement pour CI
   export CAPGO_PRIVATE_KEY="$(cat .capgo_key_v2)"
   npx @capgo/cli@latest bundle upload --key-data-v2 "$CAPGO_PRIVATE_KEY"
   ```

**Configuration de la clé publique (requise) :**
```shell
# Doit enregistrer la clé publique dans la configuration Capacitor pour l'application mobile
npx @capgo/cli@latest key save --key ./.capgo_key_v2.pub
```

**Environnement de production :**
- Stocker les clés privées dans des services de gestion de clés sécurisés (AWS KMS, Azure Key Vault, etc.)
- Utiliser la gestion des secrets CI/CD pour les clés privées
- Ne jamais valider les clés privées dans le contrôle de version

**Utilisation des clés :**
- **Clé privée** : Utilisée par CLI pour le chiffrement lors du téléchargement de bundle (garder en sécurité)
- **Clé publique** : Stockée dans la configuration de l'application pour le déchiffrement sur l'appareil (sûr à valider)

### Rotation des clés

Effectuez régulièrement une rotation de vos clés de chiffrement pour une sécurité renforcée :

<Steps>

1. **Générer de nouvelles clés :**
   ```shell
   # Naviguer d'abord vers le répertoire souhaité, puis créer les clés
   mkdir ./new-keys && cd ./new-keys
   npx @capgo/cli@latest key create
   ```

2. **Enregistrer la nouvelle clé publique dans la configuration Capacitor :**
   ```shell
   npx @capgo/cli@latest key save --key ./new-keys/.capgo_key_v2.pub
   ```

3. **Mettre à jour la configuration de votre application** avec la nouvelle clé publique

4. **Déployer l'application mise à jour** avant de télécharger des bundles chiffrés avec la nouvelle clé

</Steps>

## Meilleures pratiques de sécurité

### Sécurité des clés
- **Ne jamais partager les clés privées** entre les environnements ou les membres de l'équipe
- **Utiliser des clés différentes** pour différents environnements (dev, staging, production)
- **Effectuer une rotation régulière des clés** (recommandé : tous les 6-12 mois)
- **Stocker les clés en toute sécurité** en utilisant des systèmes de gestion de clés appropriés

### Sécurité des bundles
- **Toujours vérifier** l'intégrité du bundle après déchiffrement
- **Surveiller** les schémas de téléchargement inhabituels ou les échecs
- **Utiliser HTTPS** pour toutes les URL de bundle (requis pour les applications mobiles)
- **Implémenter** une gestion appropriée des erreurs pour les échecs de déchiffrement

### Contrôle d'accès
- **Limiter l'accès** aux clés de chiffrement au personnel autorisé uniquement
- **Utiliser un accès basé sur les rôles** pour les opérations de gestion de clés
- **Auditer** l'utilisation et l'accès aux clés régulièrement
- **Implémenter** des procédures appropriées de sauvegarde et de récupération

## Dépannage du chiffrement

### Problèmes courants

**Échecs de déchiffrement :**
- Vérifier que la clé privée correspond à la clé publique utilisée pour le chiffrement
- Vérifier que l'`ivSessionKey` est correct
- S'assurer que vous utilisez le chiffrement V2 (V1 n'est plus pris en charge)

**Erreurs liées aux clés :**
- Confirmer que le format de la clé privée est correct (format PEM)
- Vérifier que la clé n'a pas été corrompue pendant le stockage/transfert
- Vérifier que la clé a les autorisations appropriées dans la configuration de votre application

**Problèmes de performances :**
- Les gros bundles peuvent prendre plus de temps à chiffrer/déchiffrer
- Envisager d'utiliser des mises à jour différentielles pour réduire les tailles de bundle
- Surveiller les performances de l'appareil pendant le déchiffrement

### Commandes de débogage

Vérifier le statut du chiffrement :
```shell
npx @capgo/cli@latest app debug
```

Tester le flux de travail chiffrement/déchiffrement :
```shell
# Tester le flux de travail complet : zip → chiffrer → déchiffrer → dézipper
npx @capgo/cli@latest bundle zip com.example.app --key-v2
npx @capgo/cli@latest bundle encrypt ./com.example.app.zip CHECKSUM --json
npx @capgo/cli@latest bundle decrypt ./encrypted-bundle.zip IV_SESSION_KEY
```

## Conformité et normes

L'implémentation du chiffrement de Capgo suit les normes de l'industrie :

- **AES-256** : Algorithme de chiffrement approuvé FIPS 140-2
- **RSA-4096** : Chiffrement asymétrique fort pour la protection des clés
- **Mode GCM** : Fournit à la fois confidentialité et authenticité
- **Aléatoire sécurisé** : Génération de nombres aléatoires cryptographiquement sécurisée

Cela rend Capgo adapté aux applications nécessitant une conformité avec :
- RGPD (Règlement général sur la protection des données)
- HIPAA (Health Insurance Portability and Accountability Act)
- SOC 2 (Service Organization Control 2)
- ISO 27001 (Gestion de la sécurité de l'information)

## Considérations de performances

### Surcharge de chiffrement
- **Taille du bundle** : Les bundles chiffrés sont légèrement plus gros (surcharge de ~1-2%)
- **Temps de traitement** : Le chiffrement/déchiffrement ajoute une latence minimale
- **Utilisation de la mémoire** : Augmentation temporaire pendant les opérations de chiffrement/déchiffrement

### Conseils d'optimisation
- Utiliser des mises à jour différentielles pour minimiser le transfert de données chiffrées
- Optimiser la taille de votre bundle en convertissant les images au format WebP
- Minimiser les fichiers JavaScript et CSS avant la mise en bundle
- Supprimer les dépendances et le code inutilisés
- Surveiller les performances de l'appareil sur les appareils plus anciens/plus lents

## Prochaines étapes

- Découvrez le [Stockage personnalisé](/docs/live-updates/custom-storage/) pour utiliser le chiffrement avec votre propre infrastructure
- Explorez les [Canaux](/docs/live-updates/channels/) pour gérer les bundles chiffrés à travers les environnements
- Configurez l'[Intégration CI/CD](/docs/getting-started/cicd-integration/) pour automatiser les déploiements chiffrés
