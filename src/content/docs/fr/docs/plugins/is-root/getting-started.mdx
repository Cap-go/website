---
title: Commencer
description: Apprenez à installer et utiliser le plugin Is Root pour détecter les appareils Android rootés et les émulateurs pour une sécurité applicative renforcée.
sidebar:
  order: 2
locale: fr
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Installation

<Tabs>
  <TabItem label="npm">
    ```bash
    npm install @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="yarn">
    ```bash
    yarn add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="pnpm">
    ```bash
    pnpm add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="bun">
    ```bash
    bun add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
</Tabs>

## Support des plateformes

- **Android** : Support complet pour la détection de root et d'émulateur
- **iOS** : Aucune configuration requise (le plugin est axé sur Android)

## Exemple d'utilisation

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

// Détection de root basique
const rootResult = await IsRoot.isRooted();
if (rootResult.isRooted) {
  console.log('L\'appareil est rooté');
  // Gérez l'appareil rooté de manière appropriée
  // Exemple : Afficher un avertissement, limiter les fonctionnalités ou bloquer l'accès
}

// Détection de root étendue avec BusyBox
const extendedResult = await IsRoot.isRootedWithBusyBox();
if (extendedResult.isRooted) {
  console.log('L\'appareil est rooté (vérification étendue)');
}

// Vérifier la présence d'un émulateur
const emulatorResult = await IsRoot.isRunningOnEmulator();
if (emulatorResult.isEmulator) {
  console.log('Fonctionne sur émulateur');
  // Gérer l'environnement émulateur
}

// Détecter les applications de gestion root
const rootAppsResult = await IsRoot.detectRootManagementApps();
if (rootAppsResult.hasRootApps) {
  console.log('Applications de gestion root détectées');
}

// Vérifier le binaire su
const suResult = await IsRoot.checkForSuBinary();
if (suResult.hasSu) {
  console.log('Binaire SU trouvé sur l\'appareil');
}
```

## Référence API

### isRooted()

```typescript
isRooted() => Promise<{ isRooted: boolean }>
```

Effectue une détection complète de root en utilisant les méthodes par défaut.

**Retourne :** `Promise<{ isRooted: boolean }>`

### isRootedWithBusyBox()

```typescript
isRootedWithBusyBox() => Promise<{ isRooted: boolean }>
```

Détection de root étendue incluant les vérifications BusyBox.

**Retourne :** `Promise<{ isRooted: boolean }>`

### detectRootManagementApps()

```typescript
detectRootManagementApps() => Promise<{ hasRootApps: boolean }>
```

Identifie les applications de gestion root installées (SuperSU, Magisk, etc.).

**Retourne :** `Promise<{ hasRootApps: boolean }>`

### checkForSuBinary()

```typescript
checkForSuBinary() => Promise<{ hasSu: boolean }>
```

Vérifie la présence du binaire `su` dans les chemins système.

**Retourne :** `Promise<{ hasSu: boolean }>`

### isRunningOnEmulator()

```typescript
isRunningOnEmulator() => Promise<{ isEmulator: boolean }>
```

Détecte les empreintes communes des émulateurs Android.

**Retourne :** `Promise<{ isEmulator: boolean }>`

## Vérification de sécurité complète

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

async function performSecurityCheck() {
  const checks = {
    rooted: false,
    emulator: false,
    rootApps: false,
    suBinary: false
  };

  try {
    // Exécuter toutes les méthodes de détection
    const [rootResult, emulatorResult, rootAppsResult, suResult] = await Promise.all([
      IsRoot.isRootedWithBusyBox(),
      IsRoot.isRunningOnEmulator(),
      IsRoot.detectRootManagementApps(),
      IsRoot.checkForSuBinary()
    ]);

    checks.rooted = rootResult.isRooted;
    checks.emulator = emulatorResult.isEmulator;
    checks.rootApps = rootAppsResult.hasRootApps;
    checks.suBinary = suResult.hasSu;

    // Déterminer le niveau de sécurité
    const securityIssues = Object.values(checks).filter(v => v).length;

    if (securityIssues > 0) {
      console.warn(`L'appareil a ${securityIssues} problème(s) de sécurité`, checks);
      return {
        secure: false,
        issues: checks
      };
    }

    return {
      secure: true,
      issues: checks
    };
  } catch (error) {
    console.error('La vérification de sécurité a échoué:', error);
    throw error;
  }
}

// Utiliser dans votre application
const securityStatus = await performSecurityCheck();
if (!securityStatus.secure) {
  // Gérer l'appareil non sécurisé
  showSecurityWarning(securityStatus.issues);
}
```

## Techniques de détection

### Détection de root

Le plugin emploie plusieurs méthodes de détection :

- Vérifie les applications de gestion root (SuperSU, Magisk, KingRoot, etc.)
- Analyse les propriétés système suspectes
- Identifie les tags de build de test et les drapeaux de débogage
- Valide les emplacements de binaires dangereux
- Examine les permissions des chemins système
- Détecte les applications de dissimulation de root connues

### Détection d'émulateur

- Analyse de l'empreinte matérielle
- Inspection des propriétés de build
- Caractéristiques spécifiques à l'émulateur
- Indicateurs d'environnement virtuel

## Gestion des problèmes de sécurité

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

async function handleDeviceSecurity() {
  const rootResult = await IsRoot.isRooted();

  if (rootResult.isRooted) {
    // Option 1 : Afficher un avertissement et continuer
    showWarning('Votre appareil semble être rooté. Certaines fonctionnalités peuvent être limitées.');

    // Option 2 : Limiter les fonctionnalités
    disableSensitiveFeatures();

    // Option 3 : Bloquer l'accès à l'application
    showBlockedScreen('Cette application ne peut pas fonctionner sur des appareils rootés pour des raisons de sécurité.');
    return false;
  }

  return true;
}

function showWarning(message: string) {
  // Afficher une boîte de dialogue d'avertissement conviviale
  alert(message);
}

function disableSensitiveFeatures() {
  // Désactiver le traitement des paiements, l'accès aux données sensibles, etc.
  console.log('Fonctionnalités sensibles désactivées en raison de l\'appareil rooté');
}

function showBlockedScreen(message: string) {
  // Afficher un écran de blocage et quitter l'application
  alert(message);
}
```

## Bonnes pratiques

- Utilisez plusieurs méthodes de détection pour une meilleure précision
- Implémentez une dégradation gracieuse plutôt que de bloquer complètement l'accès
- Fournissez une communication claire aux utilisateurs sur les préoccupations de sécurité
- Considérez l'expérience utilisateur lors de l'implémentation de mesures de sécurité
- Maintenez le plugin à jour car les méthodes de détection évoluent
- Testez sur des appareils rootés et non rootés
- Gérez les échecs de détection avec élégance

## Considérations de sécurité

- Aucune méthode de détection n'est infaillible à 100%
- Les utilisateurs avancés peuvent contourner les mécanismes de détection
- Utilisez en combinaison avec des mesures de sécurité côté serveur
- Considérez la confidentialité des utilisateurs lors de l'implémentation de vérifications de sécurité
- Suivez les directives de la plateforme pour les implémentations de sécurité
- Mises à jour régulières recommandées car les techniques de dissimulation de root évoluent

## Cas d'utilisation

- **Applications bancaires et financières** : Empêcher l'accès sur des appareils compromis
- **Contenu protégé par DRM** : Protéger le matériel protégé par des droits d'auteur
- **Applications d'entreprise** : Appliquer les politiques de sécurité BYOD
- **Traitement des paiements** : Assurer un environnement de transaction sécurisé
- **Applications de données sensibles** : Protéger les informations confidentielles
