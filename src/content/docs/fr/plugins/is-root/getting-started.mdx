---
locale: fr
title: Commencer
description: Learn how to Installer and use the Is Root plugin to detect rooted Android Appareils and emulators for enhanced Application Sécurité.
sidebar: 
  order: 2
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Installation

<Tabs>
  <TabItem label="npm">
    ```bash
    npm install @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="yarn">
    ```bash
    yarn add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="pnpm">
    ```bash
    pnpm add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
  <TabItem label="bun">
    ```bash
    bun add @capgo/capacitor-is-root
    npx cap sync
    ```
  </TabItem>
</Tabs>

## Platform Support

- **Android**: Full Support for root and emulator detection
- **iOS**: No Configuration required (plugin is Android-focused)

## Utilisation Exemple

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

// Basic root detection
const rootResult = await IsRoot.isRooted();
if (rootResult.isRooted) {
  console.log('Device is rooted');
  // Handle rooted device appropriately
  // Example: Show warning, limit functionality, or block access
}

// Extended root detection with BusyBox
const extendedResult = await IsRoot.isRootedWithBusyBox();
if (extendedResult.isRooted) {
  console.log('Device is rooted (extended check)');
}

// Check for emulator
const emulatorResult = await IsRoot.isRunningOnEmulator();
if (emulatorResult.isEmulator) {
  console.log('Running on emulator');
  // Handle emulator environment
}

// Detect root management apps
const rootAppsResult = await IsRoot.detectRootManagementApps();
if (rootAppsResult.hasRootApps) {
  console.log('Root management apps detected');
}

// Check for su binary
const suResult = await IsRoot.checkForSuBinary();
if (suResult.hasSu) {
  console.log('SU binary found on device');
}
```

## API Référence

### isRooted()

```typescript
isRooted() => Promise<{ isRooted: boolean }>
```

Performs comprehensive root detection using default methods.

**Returns:** `Promise<{ isRooted: boolean }>`

### isRootedWithBusyBox()

```typescript
isRootedWithBusyBox() => Promise<{ isRooted: boolean }>
```

Extended root detection including BusyBox checks.

**Returns:** `Promise<{ isRooted: boolean }>`

### detectRootManagementApps()

```typescript
detectRootManagementApps() => Promise<{ hasRootApps: boolean }>
```

Identifies installed root management applications (SuperSU, Magisk, etc.).

**Returns:** `Promise<{ hasRootApps: boolean }>`

### checkForSuBinary()

```typescript
checkForSuBinary() => Promise<{ hasSu: boolean }>
```

Checks for the presence of `su` binary in system paths.

**Returns:** `Promise<{ hasSu: boolean }>`

### isRunningOnEmulator()

```typescript
isRunningOnEmulator() => Promise<{ isEmulator: boolean }>
```

Detects common Android emulator fingerprints.

**Returns:** `Promise<{ isEmulator: boolean }>`

## Comprehensive Sécurité Vérifier

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

async function performSecurityCheck() {
  const checks = {
    rooted: false,
    emulator: false,
    rootApps: false,
    suBinary: false
  };

  try {
    // Run all detection methods
    const [rootResult, emulatorResult, rootAppsResult, suResult] = await Promise.all([
      IsRoot.isRootedWithBusyBox(),
      IsRoot.isRunningOnEmulator(),
      IsRoot.detectRootManagementApps(),
      IsRoot.checkForSuBinary()
    ]);

    checks.rooted = rootResult.isRooted;
    checks.emulator = emulatorResult.isEmulator;
    checks.rootApps = rootAppsResult.hasRootApps;
    checks.suBinary = suResult.hasSu;

    // Determine security level
    const securityIssues = Object.values(checks).filter(v => v).length;

    if (securityIssues > 0) {
      console.warn(`Device has ${securityIssues} security concern(s)`, checks);
      return {
        secure: false,
        issues: checks
      };
    }

    return {
      secure: true,
      issues: checks
    };
  } catch (error) {
    console.error('Security check failed:', error);
    throw error;
  }
}

// Use in your app
const securityStatus = await performSecurityCheck();
if (!securityStatus.secure) {
  // Handle insecure device
  showSecurityWarning(securityStatus.issues);
}
```

## Detection Techniques

### Root Detection

The plugin employs multiple detection methods:

- Checks for root management applications (SuperSU, Magisk, KingRoot, etc.)
- Scans for suspicious system properties
- Identifies Test Construction tags and Débogage flags
- Validates dangerous binary locations
- Examines system path permissions
- Detects known root cloaking apps

### Emulator Detection

- Hardware fingerprint analysis
- Construction property inspection
- Emulator-specific characteristics
- Virtual environment indicators

## Handling Sécurité Issues

```typescript
import { IsRoot } from '@capgo/capacitor-is-root';

async function handleDeviceSecurity() {
  const rootResult = await IsRoot.isRooted();

  if (rootResult.isRooted) {
    // Option 1: Show warning and continue
    showWarning('Your device appears to be rooted. Some features may be limited.');

    // Option 2: Limit functionality
    disableSensitiveFeatures();

    // Option 3: Block access to app
    showBlockedScreen('This app cannot run on rooted devices for security reasons.');
    return false;
  }

  return true;
}

function showWarning(message: string) {
  // Show user-friendly warning dialog
  alert(message);
}

function disableSensitiveFeatures() {
  // Disable payment processing, sensitive data access, etc.
  console.log('Sensitive features disabled due to rooted device');
}

function showBlockedScreen(message: string) {
  // Show blocking screen and exit app
  alert(message);
}
```

## Best Practices

- Use multiple detection methods for higher accuracy
- Implement graceful degradation rather than blocking access entirely
- Provide clear Utilisateur communication À propos Sécurité concerns
- Consider the Utilisateur experience when implementing Sécurité measures
- Keep the plugin updated as detection methods evolve
- Test on both rooted and non-rooted Appareils
- Handle detection failures gracefully

## Sécurité Considerations

- No detection method is 100% foolproof
- Advanced Utilisateurs can bypass detection mechanisms
- Use in combination with server-side Sécurité measures
- Consider Utilisateur privacy when implementing Sécurité checks
- Follow platform guidelines for Sécurité implementations
- Regular Mises à jour recommended as root hiding techniques evolve

## Use Cases

- **Banking and financial apps**: Prevent access on compromised Appareils
- **DRM-protected content**: Protect copyrighted material
- **Entreprise apps**: Enforce BYOD Sécurité policies
- **Payment processing**: Ensure secure transaction environment
- **Sensitive data apps**: Protect confidential Information
