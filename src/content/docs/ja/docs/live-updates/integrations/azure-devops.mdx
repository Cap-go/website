---
title: Azure DevOps統合
description: "Azure DevOps PipelinesとCapgo Live Updatesを統合して、アプリのアップデートの自動デプロイメントを実現する方法を学びます。"
locale: ja
sidebar:
  order: 1
---

import { Aside, Steps } from '@astrojs/starlight/components';

Capgo Live UpdatesをAzure DevOps Pipelinesと統合して、コード変更をプッシュするたびにアプリのアップデートを自動的にデプロイします。このガイドでは、自動ビルド、テスト、デプロイメントワークフローの設定について説明します。

## 前提条件

Azure DevOps統合を設定する前に、以下を確認してください：

- Azure DevOps組織とプロジェクト
- アプリが構成されたCapgoアカウント
- Azure Repos Gitリポジトリにアプリのソースコードがあること
- プロジェクトでNode.jsとnpm/yarnが構成されていること

## Azure DevOps Pipelineの設定

### ステップ1: Pipelineの変数を作成

まず、Azure DevOpsプロジェクトで必要な変数を設定します：

<Steps>

1. Azure DevOpsプロジェクトに移動
2. **Pipelines** → **Library** → **Variable groups**に移動
3. `Capgo-Variables`という名前の新しい変数グループを作成
4. 以下の変数を追加：

</Steps>

| 変数名 | 値 | セキュア |
|---------------|-------|---------|
| `CAPGO_TOKEN` | Capgo APIトークン | ✅ はい |

<Aside type="tip">

Capgo APIトークンは[console.capgo.app/apikeys](https://console.capgo.app/apikeys)から取得してください。アプリIDは`capacitor.config.ts`ファイルにすでに構成されています。

</Aside>

## シンプル

mainブランチへのプッシュごとに本番環境にデプロイする基本構成：

```yaml
# Simple Azure DevOps Pipeline for Capgo Live Updates
trigger:
  branches:
    include:
      - main

variables:
  - group: Capgo-Variables

jobs:
  - job: BuildAndDeploy
    displayName: 'Build and Deploy to Capgo'
    pool:
      vmImage: 'ubuntu-latest'

    steps:
      - task: NodeTool@0
        displayName: 'Setup Node.js'
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          npm install -g @capgo/cli
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production
        displayName: 'Deploy to Capgo'
```

## 高度

### フィーチャーブランチのデプロイメント

レビューとテストのためにフィーチャーブランチをテストチャネルにデプロイ：

```yaml
# Feature branch deployment
trigger:
  branches:
    include:
      - feature/*

variables:
  - group: Capgo-Variables

jobs:
  - job: DeployFeature
    displayName: 'Deploy Feature Branch'
    pool:
      vmImage: 'ubuntu-latest'
    condition: startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')

    steps:
      - task: NodeTool@0
        inputs:
          versionSpec: '22.x'

      - script: |
          npm ci
          npm run test
          npm run build
        displayName: 'Install, test and build'

      - script: |
          BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | sed 's/[^a-zA-Z0-9-]/-/g')
          CHANNEL_NAME="feature-$BRANCH_NAME"
          npm install -g @capgo/cli
          npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
          npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME
        displayName: 'Deploy to Feature Channel'
```

<Aside type="tip">

**チャネルでのテスト**: フィーチャーチャネルにデプロイした後、アプリを特定のチャネルを使用するように構成することでアップデートをテストできます。詳しくは[アプリでチャネルを構成する方法](/docs/live-updates/channels/#configuring-the-channel-in-your-app)をご覧ください。

</Aside>

### 暗号化の使用

[Capgoの暗号化機能](/docs/live-updates/encryption/)を使用している場合、CI/CD環境にプライベートキーを安全に保存する必要があります。

ローカルで[暗号化キーを設定](/docs/live-updates/encryption/#setting-up-encryption)した後、プライベートキーをAzure DevOpsの変数に追加します：

```shell
# プライベートキーの内容を表示（この出力をコピー）
cat .capgo_key_v2
```

この内容を`CAPGO_PRIVATE_KEY`としてAzure DevOpsの変数グループに追加し（シークレットとしてマーク）、パイプラインで使用します：

```yaml
# Deploy with encryption
- script: |
    npm install -g @capgo/cli
    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --key-data-v2 "$(CAPGO_PRIVATE_KEY)" --channel production
  displayName: 'Deploy to Capgo with Encryption'
```

<Aside type="caution">

**セキュリティのベストプラクティス:**
- `.capgo_key_v2`ファイルをバージョン管理にコミットしないでください
- プライベートキーは安全なCI/CDシークレット管理にのみ保存してください
- 異なる環境には異なるキーを使用してください

</Aside>

### マルチチャネル構成

複数のデプロイメントチャネルの設定と管理に関する包括的な情報については、[チャネルドキュメント](/docs/live-updates/channels/)を参照してください。

複数の環境とプルリクエストのデプロイメントを含む完全な構成：

```yaml
# Advanced Azure DevOps Pipeline with Multiple Channels
trigger:
  branches:
    include:
      - main
      - develop

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: Capgo-Variables

stages:
  # Build stage
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  # Deploy to development
  - stage: DeployDev
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDevelopment
        environment: development
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel development --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Development'

  # Deploy PR to test channel
  - stage: DeployPR
    condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))
    jobs:
      - job: DeployPRChannel
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - task: DownloadBuildArtifacts@0
            inputs:
              artifactName: 'app-build'
              downloadPath: '$(Pipeline.Workspace)'

          - script: |
              CHANNEL_NAME="pr-$(System.PullRequest.PullRequestNumber)"
              npm install -g @capgo/cli
              npx @capgo/cli channel create $CHANNEL_NAME --apikey $(CAPGO_TOKEN) || true
              npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel $CHANNEL_NAME --path $(Pipeline.Workspace)/app-build
            displayName: 'Deploy to PR Channel'

  # Deploy to production
  - stage: DeployProd
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: DeployProduction
        environment: production
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: NodeTool@0
                  inputs:
                    versionSpec: '22.x'

                - task: DownloadBuildArtifacts@0
                  inputs:
                    artifactName: 'app-build'
                    downloadPath: '$(Pipeline.Workspace)'

                - script: |
                    npm install -g @capgo/cli
                    npx @capgo/cli bundle upload --apikey $(CAPGO_TOKEN) --channel production --path $(Pipeline.Workspace)/app-build
                  displayName: 'Deploy to Production'
```

### マルチ環境デプロイメント

複数の環境を持つ複雑なシナリオの場合：

```yaml
# Extended pipeline with multiple environments
parameters:
  - name: deployEnvironment
    displayName: 'Deploy Environment'
    type: string
    default: 'staging'
    values:
      - staging
      - production

variables:
  - group: Capgo-Variables
  - name: channelName
    ${{ if eq(parameters.deployEnvironment, 'production') }}:
      value: 'production'
    ${{ else }}:
      value: 'staging'

stages:
  # Build stage
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'staging'))
    jobs:
      - deployment: DeployStaging
        displayName: 'Deploy to Staging Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'staging'

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: Build
    condition: and(succeeded(), eq('${{ parameters.deployEnvironment }}', 'production'))
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: 'production'
```

### デプロイメントテンプレート (deploy-steps.yml)

再利用可能なテンプレートファイル`deploy-steps.yml`を作成：

```yaml
# deploy-steps.yml
parameters:
  - name: channel
    type: string

steps:
  - task: NodeTool@0
    displayName: 'Install Node.js'
    inputs:
      versionSpec: '22.x'

  - task: DownloadBuildArtifacts@0
    displayName: 'Download build artifacts'
    inputs:
      artifactName: 'app-build'
      downloadPath: '$(System.ArtifactsDirectory)'

  - script: |
      npm install -g @capgo/cli
    displayName: 'Install Capgo CLI'

  - script: |
      npx @capgo/cli bundle upload \
        --apikey $(CAPGO_TOKEN) \
        --channel ${{ parameters.channel }} \
        --path $(System.ArtifactsDirectory)/app-build
    displayName: 'Upload to Capgo (${{ parameters.channel }})'
```

### ブランチベースのデプロイメント戦略

Gitブランチに基づいて異なるデプロイメント戦略を構成：

```yaml
trigger:
  branches:
    include:
      - main
      - develop
      - feature/*

variables:
  - group: Capgo-Variables
  - name: targetChannel
    ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
      value: 'production'
    ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
      value: 'staging'
    ${{ else }}:
      value: 'development'

stages:
  - stage: Build
    jobs:
      - job: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '22.x'

          - script: |
              npm ci
              npm run test
              npm run build
            displayName: 'Install, test and build'

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: 'dist'
              artifactName: 'app-build'

  - stage: Deploy
    displayName: 'Deploy to $(targetChannel)'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - deployment: DeployJob
        displayName: 'Deploy to $(targetChannel) Channel'
        pool:
          vmImage: 'ubuntu-latest'
        environment: '$(targetChannel)'
        strategy:
          runOnce:
            deploy:
              steps:
                - template: deploy-steps.yml
                  parameters:
                    channel: '$(targetChannel)'
```

## セキュリティのベストプラクティス

### 安全な変数管理

<Steps>

1. **変数グループを使用**: 機密データをAzure DevOps変数グループに保存
2. **シークレットとしてマーク**: APIトークンとキーは常にシークレット変数としてマーク
3. **アクセスのスコープ**: 変数グループのアクセスを特定のパイプラインとユーザーに制限
4. **キーのローテーション**: Capgo APIトークンを定期的にローテーション

</Steps>

## 監視と通知

### Teams統合

パイプラインにMicrosoft Teams通知を追加：

```yaml
- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Success'
  condition: succeeded()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Successful'
    text: 'App deployed to $(targetChannel) channel'
    themeColor: '00FF00'

- task: ms-teams-deploy-card@1.4.1
  displayName: 'Notify Teams on Failure'
  condition: failed()
  inputs:
    webhookUri: '$(TEAMS_WEBHOOK_URL)'
    title: 'Capgo Deployment Failed'
    text: 'Deployment to $(targetChannel) failed'
    themeColor: 'FF0000'
```

### メール通知

デプロイメントステータスのメール通知を構成：

```yaml
- task: EmailReport@1
  displayName: 'Send Email Report'
  condition: always()
  inputs:
    sendMailConditionConfig: 'Always'
    subject: 'Capgo Deployment Report - $(Build.BuildNumber)'
    to: 'team@yourcompany.com'
    body: |
      Deployment Status: $(Agent.JobStatus)
      Channel: $(targetChannel)
      Build: $(Build.BuildNumber)
      Commit: $(Build.SourceVersion)
```

## トラブルシューティング

### 一般的な問題

**「Capgo CLI not found」でパイプラインが失敗:**
```yaml
# グローバルインストールを確認
- script: |
    npm install -g @capgo/cli
    which capgo || echo "Capgo CLI not found in PATH"
  displayName: 'Install and verify Capgo CLI'
```

**認証エラー:**
```yaml
# トークンが正しく設定されているか確認
- script: |
    echo "Token length: ${#CAPGO_TOKEN}"
    if [ -z "$CAPGO_TOKEN" ]; then
      echo "CAPGO_TOKEN is not set"
      exit 1
    fi
  displayName: 'Verify Capgo token'
  env:
    CAPGO_TOKEN: $(CAPGO_TOKEN)
```

**ビルドアーティファクトが見つからない:**
```yaml
# デバッグ用に利用可能なアーティファクトをリスト
- script: |
    ls -la $(System.ArtifactsDirectory)
    find $(System.ArtifactsDirectory) -name "*.js" -o -name "*.html"
  displayName: 'Debug artifacts'
```

### デバッグパイプライン

問題をトラブルシューティングするためのデバッグステップを追加：

```yaml
- script: |
    echo "Build.SourceBranch: $(Build.SourceBranch)"
    echo "Build.BuildNumber: $(Build.BuildNumber)"
    echo "Target Channel: $(targetChannel)"
  displayName: 'Debug Pipeline Variables'

- script: |
    npx @capgo/cli app debug --apikey $(CAPGO_TOKEN)
  displayName: 'Debug Capgo App Status'
```

## 次のステップ

- [チャネル](/docs/live-updates/channels/)について学び、異なるデプロイメント環境を管理
- 高度なデプロイメントシナリオのための[カスタムストレージ](/docs/live-updates/custom-storage/)を探索
- 安全なデプロイメントのための[暗号化](/docs/live-updates/encryption/)を設定
- アップデートの適用方法をカスタマイズするための[アップデート動作](/docs/live-updates/update-behavior/)を構成

Azure DevOps統合により、Capgoデプロイメントを自動化し、モバイルアプリユーザーへの一貫性のある信頼性の高いアップデートを保証できます。
