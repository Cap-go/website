---
title: チャンネル
sidebar:
  order: 2
locale: ja
---

import { Aside, Steps } from '@astrojs/starlight/components';

ライブアップデートチャンネルは、そのチャンネルのアップデートを受信するように設定された任意のデバイスと共有される、アプリの特定のJSバンドルビルドを指します。アプリに[Capgo Live Updates SDKをインストール](/docs/getting-started/quickstart/)すると、そのチャンネルに設定された任意のネイティブバイナリは、アプリが起動されるたびに利用可能なアップデートを確認します。チャンネルが指すビルドはいつでも変更でき、必要に応じて以前のビルドにロールバックすることもできます。

## チャンネルの設定

すべてのアプリには、削除できないデフォルトの「Production」チャンネルが付属しています。新しいチャンネルを追加するには：

1. Capgoダッシュボードの「Channels」セクションに移動します
2. 「New Channel」ボタンをクリックします
3. チャンネルの名前を入力し、「Create」をクリックします

チャンネル名は任意のものを使用できます。一般的な戦略として、以下のような開発段階にチャンネルを対応させることがあります：

- `Development` - ローカルデバイスまたはエミュレータでライブアップデートをテストするため
- `QA` - QAチームが広範なリリース前にアップデートを検証するため
- `Staging` - 本番環境に近い環境での最終テストのため
- `Production` - エンドユーザーがアプリストアから受け取るアプリのバージョン用

## アプリでのチャンネルの設定

チャンネルを作成したら、適切なチャンネルを監視するようにアプリを設定する必要があります。この例では、`Development`チャンネルを使用します。

`capacitor.config.ts`（または`capacitor.config.json`）ファイルを開きます。`plugins`セクションで、`CapacitorUpdater`プラグインの`channel`プロパティを希望のチャンネル名に設定します：

```ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  plugins: {
    CapacitorUpdater: {
      defaultChannel: 'Development',
    },
  },
};
```

次に、Webアプリをビルドし、`npx cap sync`を実行して更新された設定ファイルをiOSとAndroidプロジェクトにコピーします。この同期ステップをスキップすると、ネイティブプロジェクトは以前に設定されていたチャンネルを引き続き使用します。

<Aside type="caution">

`defaultChannel`プロパティは常にクラウドのデフォルトチャンネルをオーバーライドしますが、クラウドでデバイスIDをチャンネルに強制することはできます。

</Aside>

## チャンネルへのバンドルの割り当て

ライブアップデートをデプロイするには、新しいJSバンドルビルドをアップロードし、それをチャンネルに割り当てる必要があります。Capgo CLIを使用して1つのステップでこれを行うことができます：

```shell
npx @capgo/cli@latest upload --channel=Development
```

これによりビルドされたWebアセットがアップロードされ、新しいバンドルが`Development`チャンネルのアクティブビルドとして設定されます。そのチャンネルを監視するように設定されているアプリは、次回のアップデートチェック時に更新を受信します。

Capgoダッシュボードの「Bundles」セクションからもビルドをチャンネルに割り当てることができます。ビルドの横にあるメニューアイコンをクリックし、「Assign to Channel」を選択してそのビルドのチャンネルを選択します。

## バンドルのバージョニングとチャンネル

Capgoのバンドルは個々のチャンネルに特化したものではなく、アプリ全体でグローバルであることに注意することが重要です。同じバンドルを複数のチャンネルに割り当てることができます。

バンドルのバージョニングでは、チャンネル固有のビルドにはプレリリース識別子を使用したセマンティックバージョニング[semver](https://semver.org/)を推奨します。例えば、ベータリリースは`1.2.3-beta.1`としてバージョン付けされます。

このアプローチには以下のような利点があります：

- ビルド間の関係を明確に伝えます。`1.2.3-beta.1`は明らかに`1.2.3`のプレリリースです
- チャンネル間でバージョン番号を再利用できるため、混乱を減らせます
- 明確なロールバックパスが可能です。`1.2.3`からロールバックする必要がある場合、`1.2.2`が前の安定リリースだとわかります

典型的なチャンネル設定でのバンドルバージョンの例：

- `Development`チャンネル：`1.2.3-dev.1`、`1.2.3-dev.2`など
- `QA`チャンネル：`1.2.3-qa.1`、`1.2.3-qa.2`など
- `Staging`チャンネル：`1.2.3-rc.1`、`1.2.3-rc.2`など
- `Production`チャンネル：`1.2.3`、`1.2.4`など

プレリリース識別子を使用したsemverは推奨されるアプローチですが、必須ではありません。重要なのは、ビルド間の関係を明確に伝え、チームの開発プロセスに合ったバージョニング方式を見つけることです。

## ライブアップデートのロールバック

バグを導入するライブアップデートをデプロイした場合や、その他の理由で元に戻す必要がある場合は、簡単に以前のビルドにロールバックできます。ダッシュボードの「Channels」セクションから：

<Steps>

1. ロールバックしたいチャンネルの名前をクリックします
2. 戻したいビルドを見つけ、クラウンアイコンをクリックします
![ロールバックビルド](/select_bundle.webp)
3. アクションを確認します

</Steps>

選択したビルドは直ちにそのチャンネルのアクティブビルドとなります。アプリは次回のアップデートチェック時にロールバックされたバージョンを受信します。

## デプロイメントの自動化

より高度なワークフローでは、CI/CDパイプラインの一部としてライブアップデートのデプロイメントを自動化できます。Capgoをビルドプロセスに統合することで、特定のブランチへのプッシュや新しいリリースの作成時に自動的に新しいバンドルをアップロードし、チャンネルに割り当てることができます。

Capgoライブアップデートの自動化については、[CI/CD Integration](/docs/cicd-integration/)ドキュメントを参照してください。

## デバイスへのデプロイ

チャンネルについて理解したら、実際のデバイスへのライブアップデートのデプロイを開始する準備が整いました。基本的なプロセスは：

1. アプリにCapgo SDKをインストールします
2. 希望のチャンネルを監視するようにアプリを設定します
3. ビルドをアップロードしてそのチャンネルに割り当てます
4. アプリを起動してアップデートを待ちます！

より詳細な手順については、[Deploying Live Updates](/docs/getting-started/deploy/)ガイドを参照してください。Happy updating!