---
title: 暗号化
description: "Capgoのエンドツーエンド暗号化がどのように送信と保存中にアプリバンドルを保護し、コードとユーザーデータを守るかを学びます。"
locale: ja
sidebar:
  order: 5
---

import { Aside, Steps } from '@astrojs/starlight/components';

Capgoは、アプリバンドルに対する堅牢なエンドツーエンド暗号化を提供し、JavaScriptコードとアセットが送信と保存中に保護されることを保証します。この暗号化システムは、ライブアップデートの利便性を維持しながら、アプリのセキュリティを完全に制御できるように設計されています。

## 概要

Capgoの暗号化システムは、業界標準の暗号化方式を使用して、バンドルを不正アクセスから保護します。暗号化が有効になっている場合、バンドルは開発環境を離れる前に暗号化され、ユーザーのデバイス上のアプリによって復号化されるまで暗号化されたままになります。

**真のエンドツーエンド暗号化**: アップデートに署名するだけ（コードが公開的に読み取り可能）の他のOTAアップデートプラットフォームとは異なり、Capgoは真のエンドツーエンド暗号化を提供します。これは、ユーザーのみがアップデートを復号化でき、Capgo自体を含む他の誰もできないことを意味します。バンドルコンテンツは、配信プロセス全体を通じて完全にプライベートで読み取り不可能なままです。

<Aside type="tip">

暗号化は以下の場合に特に重要です：
- 機密データまたはビジネスロジックを扱うアプリ
- コンプライアンス要件を持つエンタープライズアプリケーション
- 規制された業界に展開されるアプリ
- 厳格なセキュリティポリシーを持つ組織

</Aside>

## 暗号化の仕組み

Capgoは、最適なセキュリティとパフォーマンスのためにRSAとAES暗号化を組み合わせたハイブリッド暗号化アプローチを使用します：

![Capgo暗号化フロー](/encryption_flow.webp)

### 1. 鍵生成
- **プライベートキー**: 開発環境で生成され、安全に保存されます（暗号化に使用）
- **パブリックキー**: プライベートキーから派生し、アプリのCapacitor configに保存されます（復号化に使用）
- **セッションキー**: 各バンドルアップロードに対してランダムなAESキーが生成されます

### 2. 暗号化プロセス
1. 各バンドルアップロードに対してランダムなAESセッションキーが生成されます
2. バンドルはAESセッションキーを使用して暗号化されます
3. バンドルチェックサムが計算されます
4. AESセッションキーとチェックサムの両方がRSAプライベートキーを使用して一緒に暗号化されます（「署名」を作成）
5. 暗号化されたバンドルと暗号化された署名が保存されます

チェックサムはAESキーと一緒に暗号化されて改ざんを防ぎます。RSAプライベートキーのみがこの署名を作成でき、対応するパブリックキーのみがそれを復号化できるため、AESセッションキーと予期されるチェックサムの両方が真正であり、攻撃者によって変更されていないことが保証されます。

### 3. 復号化プロセス
1. アプリは暗号化されたバンドルと暗号化された署名をダウンロードします
2. Capgo SDKは、RSAパブリックキー（アプリに保存）を使用して署名を復号化します
3. これによりAESセッションキーと元のチェックサムが明らかになります
4. AESセッションキーを使用してバンドルを復号化します
5. 復号化されたバンドルのチェックサムが計算され、整合性検証のために元のチェックサムと比較されます

このプロセスにより、攻撃者が暗号化されたバンドルを傍受しても、AESセッションキーを変更したり偽のチェックサムを提供したりすることはできません。なぜなら、パブリックキーが復号化できる有効な署名を作成するには、プライベートキーが必要だからです。

<Aside type="tip">

RSAは大量のデータを効率的に暗号化できないため、実際のバンドル暗号化にはAESが使用され、RSAはAESキーを保護し、チェックサム署名を通じて整合性検証を提供します。

</Aside>

## Capgoと他のプラットフォームの比較

| 機能 | Capgo | 他のOTAプラットフォーム |
|---------|-------|-------------------|
| **バンドルコンテンツ** | 完全に暗号化（読み取り不可能） | 公開的に読み取り可能 |
| **セキュリティ方式** | 真のエンドツーエンド暗号化 | コード署名のみ |
| **プライバシーレベル** | ゼロノレッジ（Capgoでさえコードを読めない） | プラットフォームがコードにアクセス可能 |
| **保護** | コンテンツ + 整合性 + 真正性 | 整合性 + 真正性のみ |

**なぜこれが重要か:**
- **コード署名**は、アップデートが改ざんされておらず、正しいソースから来ていることを検証するだけです
- **エンドツーエンド暗号化**は、実際のコードコンテンツが送信と保存中にプライベートで読み取り不可能なままであることを保証します
- Capgoの真のエンドツーエンド暗号化により、ユーザーのみがアップデートを復号化でき、Capgo自体を含む他の誰もできません

## 暗号化方式

Capgoは暗号化V2を標準暗号化方式として使用します：

### 暗号化V2（現在の標準）
- セキュリティ強化のためRSA-4096を使用
- 認証付き暗号化のためAES-256-GCM
- 整合性検証を提供
- より優れたパフォーマンスとセキュリティ

### 暗号化V1（非推奨）
- 鍵暗号化にRSA-2048を使用
- バンドル暗号化にAES-256-CBC
- **現在のCLIでは利用できません**
- V1を使用しているレガシーアプリはV2に移行する必要があります

<Aside type="danger">

暗号化V1は現在のCapgo CLIではサポートされていません。V1暗号化を使用している場合は、V2に移行する必要があります。詳細な手順については、[移行ガイド](/docs/upgrade/encryption-v1-to-v2/)を参照してください。

</Aside>

## 暗号化の設定

### ステップ1: 暗号化キーの生成

まず、Capgo CLIを使用して暗号化キーを生成します：

```shell
# 新しい暗号化キーを生成（現在のディレクトリにファイルを作成）
npx @capgo/cli@latest key create
```

これにより以下が作成されます：
- `.capgo_key_v2`: プライベートキー（これを安全に保管してください！）
- `.capgo_key_v2.pub`: パブリックキー（アプリで使用）

これらのファイルは、コマンドを実行した現在のディレクトリに作成されます。

<Aside type="caution">

**重要な保存に関する注意:**
- **プライベートキー（`.capgo_key_v2`）**: バージョン管理にコミットしないでください。このファイルは安全に保管し、バンドルアップロード時の暗号化にのみ使用してください。
- **パブリックキー（`.capgo_key_v2.pub`）**: パブリックキーのバックアップとしてバージョン管理にコミットしても安全です。
- **ファイルの場所**: キーは`key create`コマンドを実行した現在のディレクトリに作成されます。
- **Config内のパブリックキー**: モバイルアプリが使用できるように、`key save`を実行してパブリックキーをCapacitor configに保存する必要があります。

本番環境での使用では、プライベートキーを安全に保存し（環境変数、キー管理サービス）、セットアップ後にローカルプロジェクトから削除してください。

</Aside>

### ステップ2: Capacitor Configにパブリックキーを保存（必須）

モバイルアプリがバンドルを復号化できるように、パブリックキーをCapacitor configに保存する**必要があります**：

```shell
# ファイルからCapacitor configにパブリックキーを保存（必須）
npx @capgo/cli@latest key save --key ./.capgo_key_v2.pub

# またはパブリックキーデータを直接保存
npx @capgo/cli@latest key save --key-data "$CAPGO_PUBLIC_KEY"
```

### ステップ3: Capacitorプラットフォームを同期（必須）

パブリックキーを保存した後、更新されたconfigをネイティブレイヤーにコピーするためにCapacitorプラットフォームを同期する**必要があります**：

```shell
# プラットフォームを同期してconfigをネイティブにコピー
npx cap sync
```

<Aside type="caution">

**必須ステップ**:
1. `key save`コマンドは、パブリックキーをCapacitor configに保存します
2. `npx cap sync`は、このconfigをモバイルアプリがアクセスできるネイティブレイヤーにコピーします
3. 両方のステップなしでは、アプリは暗号化されたアップデートを復号化できません

</Aside>

## バンドルの暗号化

### 方法1: アップロード時に暗号化

最も簡単な方法は、アップロードプロセス中に暗号化することです：

```shell
# 自動暗号化でアップロード
npx @capgo/cli@latest bundle upload --key-v2

# 外部ストレージの場合、最初に暗号化する必要があります（下記の手動暗号化ワークフローを参照）
```

### 方法2: 手動暗号化ワークフロー

より詳細な制御のために、バンドルを手動で暗号化できます：

<Steps>

1. **zipバンドルを作成:**
   ```shell
   npx @capgo/cli@latest bundle zip com.example.app --path ./dist --key-v2
   ```

2. **バンドルを暗号化:**
   ```shell
   npx @capgo/cli@latest bundle encrypt ./com.example.app.zip CHECKSUM_FROM_STEP_1
   ```

3. **ストレージにアップロード（例：S3）してCapgoに登録:**
   ```shell
   # まず暗号化されたバンドルをストレージにアップロード（例：AWS S3）
   aws s3 cp ./encrypted-bundle.zip s3://your-bucket/encrypted-bundle.zip

   # 次に外部URLを使用してCapgoに登録
   npx @capgo/cli@latest bundle upload --external https://your-storage.com/encrypted-bundle.zip --iv-session-key IV_SESSION_KEY_FROM_STEP_2
   ```

</Steps>

## キー管理

### キーの安全な保存

**プライベートキーのオプション:**

1. **ファイルベース（ローカル開発）:**
   ```shell
   # プロジェクトルートに.capgo_key_v2ファイルとして保存
   npx @capgo/cli@latest bundle upload --key-v2
   ```

2. **環境変数（CI/CD）:**
   ```shell
   # CI用に環境変数に保存
   export CAPGO_PRIVATE_KEY="$(cat .capgo_key_v2)"
   npx @capgo/cli@latest bundle upload --key-data-v2 "$CAPGO_PRIVATE_KEY"
   ```

**パブリックキーのセットアップ（必須）:**
```shell
# モバイルアプリ用にCapacitor configにパブリックキーを保存する必要があります
npx @capgo/cli@latest key save --key ./.capgo_key_v2.pub
```

**本番環境:**
- 安全なキー管理サービス（AWS KMS、Azure Key Vaultなど）にプライベートキーを保存
- プライベートキーにはCI/CDシークレット管理を使用
- プライベートキーをバージョン管理にコミットしない

**キーの使用:**
- **プライベートキー**: バンドルアップロード時の暗号化にCLIが使用（安全に保管）
- **パブリックキー**: デバイス上の復号化のためアプリ構成に保存（コミット可）

### キーのローテーション

セキュリティ強化のために暗号化キーを定期的にローテーション：

<Steps>

1. **新しいキーを生成:**
   ```shell
   # まず目的のディレクトリに移動してから、キーを作成
   mkdir ./new-keys && cd ./new-keys
   npx @capgo/cli@latest key create
   ```

2. **新しいパブリックキーをCapacitor configに保存:**
   ```shell
   npx @capgo/cli@latest key save --key ./new-keys/.capgo_key_v2.pub
   ```

3. **アプリ構成を新しいパブリックキーで更新**

4. **新しいキーで暗号化されたバンドルをアップロードする前に、更新されたアプリをデプロイ**

</Steps>

## セキュリティのベストプラクティス

### キーのセキュリティ
- **プライベートキーを共有しない**（環境間やチームメンバー間で）
- **異なるキーを使用**（異なる環境用：dev、staging、production）
- **定期的にキーをローテーション**（推奨：6〜12ヶ月ごと）
- **適切なキー管理システムを使用してキーを安全に保存**

### バンドルのセキュリティ
- **常に検証**（復号化後のバンドル整合性）
- **監視**（異常なダウンロードパターンや失敗）
- **HTTPSを使用**（すべてのバンドルURL用、モバイルアプリで必須）
- **適切なエラー処理を実装**（復号化失敗用）

### アクセス制御
- **アクセスを制限**（承認された担当者のみに暗号化キーへのアクセス）
- **ロールベースのアクセスを使用**（キー管理操作用）
- **定期的に監査**（キーの使用とアクセス）
- **適切なバックアップとリカバリー手順を実装**

## 暗号化のトラブルシューティング

### 一般的な問題

**復号化失敗:**
- プライベートキーが暗号化に使用されたパブリックキーと一致することを確認
- `ivSessionKey`が正しいことを確認
- 暗号化V2を使用していることを確認（V1はサポートされていません）

**キー関連のエラー:**
- プライベートキーの形式が正しいことを確認（PEM形式）
- キーが保存/転送中に破損していないことを確認
- アプリ構成でキーが適切な権限を持っていることを確認

**パフォーマンスの問題:**
- 大きなバンドルは暗号化/復号化に時間がかかる場合があります
- バンドルサイズを削減するために差分アップデートの使用を検討
- 復号化中のデバイスパフォーマンスを監視

### デバッグコマンド

暗号化ステータスを確認：
```shell
npx @capgo/cli@latest app debug
```

暗号化/復号化ワークフローをテスト：
```shell
# 完全なワークフローをテスト：zip → 暗号化 → 復号化 → 解凍
npx @capgo/cli@latest bundle zip com.example.app --key-v2
npx @capgo/cli@latest bundle encrypt ./com.example.app.zip CHECKSUM --json
npx @capgo/cli@latest bundle decrypt ./encrypted-bundle.zip IV_SESSION_KEY
```

## コンプライアンスと標準

Capgoの暗号化実装は業界標準に従います：

- **AES-256**: FIPS 140-2承認の暗号化アルゴリズム
- **RSA-4096**: キー保護のための強力な非対称暗号化
- **GCMモード**: 機密性と真正性の両方を提供
- **セキュアランダム**: 暗号学的に安全な乱数生成

これにより、Capgoは以下への準拠が必要なアプリケーションに適しています：
- GDPR（一般データ保護規則）
- HIPAA（医療保険の携行性と責任に関する法律）
- SOC 2（サービス組織管理2）
- ISO 27001（情報セキュリティマネジメント）

## パフォーマンスに関する考慮事項

### 暗号化のオーバーヘッド
- **バンドルサイズ**: 暗号化されたバンドルはわずかに大きくなります（約1〜2%のオーバーヘッド）
- **処理時間**: 暗号化/復号化は最小限の遅延を追加
- **メモリ使用量**: 暗号化/復号化操作中の一時的な増加

### 最適化のヒント
- 暗号化されたデータ転送を最小化するために差分アップデートを使用
- 画像をWebP形式に変換してバンドルサイズを最適化
- バンドル化前にJavaScriptとCSSファイルを最小化
- 未使用の依存関係とコードを削除
- 古い/遅いデバイスでデバイスパフォーマンスを監視

## 次のステップ

- [カスタムストレージ](/docs/live-updates/custom-storage/)について学び、独自のインフラストラクチャで暗号化を使用
- [チャネル](/docs/live-updates/channels/)を探索して、環境間で暗号化されたバンドルを管理
- [CI/CD統合](/docs/getting-started/cicd-integration/)をセットアップして、暗号化されたデプロイメントを自動化
